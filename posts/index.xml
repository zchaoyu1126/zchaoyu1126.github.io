<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - Chao's Blog</title><link>https://zchaoyu1126.github.io/posts/</link><description>所有文章 | Chao's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>zchaoyu1126@gmail.com (chao)</managingEditor><webMaster>zchaoyu1126@gmail.com (chao)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 06 Jul 2022 11:22:43 +0800</lastBuildDate><atom:link href="https://zchaoyu1126.github.io/posts/" rel="self" type="application/rss+xml"/><item><title>Goroutine 泄漏</title><link>https://zchaoyu1126.github.io/2022/07/goroutine-leak/</link><pubDate>Wed, 06 Jul 2022 11:22:43 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/07/goroutine-leak/</guid><description>&lt;p>Golang优秀的GC机制，虽然可以让其不需要像C++中那样手动释放对象，从而避免内存泄漏，但goroutine的生命周期需要开发者格外注意。如果一个goroutine意外阻塞无法退出，就会造成goroutine泄漏的问题。随着占用的资源越来越多，只能重启服务器暂时缓解，还是得从根源上解决问题。本文对goroutine的泄漏场景进行了总结，是对煎鱼大佬博文的梳理，内容并非原创，参考原文已贴在末尾。&lt;/p></description></item><item><title>使用Github Action自动部署Hugo</title><link>https://zchaoyu1126.github.io/2022/06/github-action-deploy-hugo/</link><pubDate>Wed, 29 Jun 2022 20:03:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/06/github-action-deploy-hugo/</guid><description>&lt;p>使用Loveit主题的拓展short codes之后，由于在markdown之中引入了&lt;code>{{}}&lt;/code>语法，使得Liquid在解析markdown中的代码块时出错，采用的解决方法是禁用Jekyll，因为hugo已经生成了静态站点所需的文件，不需要再使用Jekyll。在解决此问题的同时，学习于了解了Github上的Action功能，并使用Github Action完成了站点的自动部署。&lt;/p></description></item><item><title>Go语言学习资料</title><link>https://zchaoyu1126.github.io/2022/06/means/</link><pubDate>Tue, 28 Jun 2022 20:03:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/06/means/</guid><description>信息 以下1-5为字节青训营白嫖拿到的学习路线图 1 入门 官方课程Go语言圣经(中文版) Go by Example中文 Effective Go中文版本 标准库： Go语言标准库</description></item><item><title>ch4 网络层-IP基础</title><link>https://zchaoyu1126.github.io/2022/05/network-ch4/</link><pubDate>Mon, 30 May 2022 23:02:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/05/network-ch4/</guid><description>1 IPv4 地址 IPv4地址是一个32bit地址，唯一地与通用地定义了一个连接在因特网上的设备。IP地址采用点分十进制记法，首先每8个Bit插入一个</description></item><item><title>Ch23 同步</title><link>https://zchaoyu1126.github.io/2022/03/go-ch23/</link><pubDate>Wed, 16 Mar 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/03/go-ch23/</guid><description>ch23 同步 Go程序可以使用通道进行多个goroutine之间的数据交换，但这仅仅是数据同步中的一种方法。在一些轻量级的场合可以使用atomic，</description></item><item><title>Ch21 协程</title><link>https://zchaoyu1126.github.io/2022/03/go-ch21/</link><pubDate>Thu, 10 Mar 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/03/go-ch21/</guid><description>ch21 协程 Go语言的并发通过goroutine特性完成。goroutine类似于线程，但是可以根据需要创建多个goroutine并发工作。 gor</description></item><item><title>Ch22 通道</title><link>https://zchaoyu1126.github.io/2022/03/go-ch22/</link><pubDate>Thu, 10 Mar 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/03/go-ch22/</guid><description>ch22 通道 单纯地将函数并发执行是没有意义的，函数与函数间需要交换数据才能体现并发执行函数的意义。使用共享内存在不同的goroutine中容易发生</description></item><item><title>Ch20 接口</title><link>https://zchaoyu1126.github.io/2022/03/go-ch20/</link><pubDate>Sat, 05 Mar 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/03/go-ch20/</guid><description>ch20 map ch38 map底层实现 写在前面，map并不是并发安全的，如果需要在goroutine中使用，需要使用sync.map，更多的信息请参考 ch25 并发编</description></item><item><title>Ch19 接口</title><link>https://zchaoyu1126.github.io/2022/03/go-ch19/</link><pubDate>Fri, 04 Mar 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/03/go-ch19/</guid><description>ch19 接口 传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂</description></item><item><title>Ch18 自定义类型与结构体</title><link>https://zchaoyu1126.github.io/2022/02/go-ch18/</link><pubDate>Sun, 20 Feb 2022 20:26:12 +0800</pubDate><author>chao</author><guid>https://zchaoyu1126.github.io/2022/02/go-ch18/</guid><description>ch18 自定义类型与结构体 自定义类型 Go语言的关键字type可以将各种基本类型定义为自定义类型，而且每种自定义类型可以拥有自己的方法。 例如, 1 2 3</description></item></channel></rss>