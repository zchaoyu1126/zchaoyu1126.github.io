[{"categories":["C++"],"content":"第一章 概述 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:0","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.1 名字空间 C++标准库中的类和函数是在名字空间std中声明的。名字空间可以消除那些因重名而导致的命名冲突 💡允许使用没有名字的名字空间 由于名字空间没有名字，因此无法在其他空间中引用。 无名名字空间中的变量不必声明，可以理解为一个全局变量，再次声明相同变量名后会被覆盖。 无名名字空间内的成员的作用域为本文件从声明到文件结束。 #include \u003ciostream\u003eusing namespace std; namespace ns1 { int inflag = 1; } namespace ns2 { int inflag = 2; } namespace { int inflag = 0; } int main() { cout \u003c\u003c ns1::inflag \u003c\u003c endl; cout \u003c\u003c ns2::inflag \u003c\u003c endl2; cout \u003c\u003c inflag \u003c\u003c endl; cout \u003c\u003c \"****\" \u003c\u003c endl; ns1::inflag = 2; ns2::inflag = 3; inflag = 4; cout \u003c\u003c ns1::inflag \u003c\u003c endl; cout \u003c\u003c ns2::inflag \u003c\u003c endl2; cout \u003c\u003c inflag \u003c\u003c endl; cout \u003c\u003c \"****\" \u003c\u003c endl; int inflag = 1; cout \u003c\u003c inflag \u003c\u003c endl; return 0; } // 1 // 2 // 0 // **** // 2 // 3 // 4 // **** // 1 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:1","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.2 定义常量 格式： const int MAXLine = 1000 注意：定义时必须初始化，且不可再次赋值 💡宏定义与常量的区别 const常量有数据类型，而宏常量没有数据类型 宏常量有时可能会导致某些错误，例如 #define x a+b 若在程序中写了x*4此类表达，则会出错 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:2","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.3 函数重载 函数的参数个数不同 函数的参数类型不同 函数必须同名 const关键字可以用于区分重载函数（见后） ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:3","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.4 函数模板 函数模板不是一个函数，编译系统不产生任何执行代码，当编译程序发现与函数模板中相匹配的函数调用时，生成一个重载函数。 该重载函数称为模板函数，是函数模板的一个实例，只处理一种唯一的数据类型。 template \u003cclass T1, class T2, class T3\u003e T1 max(T2 a, T3 b){ return (a\u003eb)?(T1)a:(T2)b; } ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:4","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.5 带默认参数的函数 实参与形参的结合顺序，从左到右，故带默认参数的参数必须在最右边 注意与重载函数共同使用时可能会出现二义性问题 函数声明中给形参指定默认值，又在函数定义中给形参指定默认值，有些编译器会报错，有些会通过（以第一次为准），一般在函数声明中赋值（老师上课所讲，了解即可） ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:5","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.6 引用 💡引用的核心 引用的核心就是一个地址两个名字。 引用时必须初始化 初始化值不能是一个常数 一旦被声明就不能指向其他变量 引用是变量的另一个名字，可以对引用进行赋值，取址等操作 以下的声明是非法的 void\u0026 test1 = max; // 不允许使用对void的引用 int\u0026 a[6] = ... // 不允许使用引用的数组 int\u0026* p = max; // 不允许使用指向引用的指针 💡指向引用的指针和指向指针的引用 指针需要指向内存空间，而引用只是一个别名而已，不是内存空间。 引用不是一个对象，所以就不会存在指向引用的指针，但指针是对象，所以存在指向指针的引用。 int\u0026* p 指向引用的指针 不合法 int*\u0026 p 指向指针的引用 合法 #include \u003ciostream\u003eusing namespace std; int main() { //引用的定义,可以是变量名也可以是另一个引用 int max = 1; int* pmax = \u0026max; int nums[6]; int\u0026 refmax = max; int\u0026 reffmax = refmax; cout \u003c\u003c max \u003c\u003c endl; refmax++; cout \u003c\u003c max \u003c\u003c endl; reffmax++; cout \u003c\u003c max \u003c\u003c endl; //三者全部指向max,皆可对该内存单元进行操作 // void\u0026 test1 = max; // 不允许使用对void的引用 // int\u0026 a[6] = ... // 不允许使用引用的数组 // int\u0026* p = max; // 不允许使用指向引用的指针 int*\u0026 p = pmax; cout \u003c\u003c (*p) \u003c\u003c \" \" \u003c\u003c p \u003c\u003c endl; } ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:6","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.7 const与常引用 const是用作定义常量，一旦某个对象定义为一个常量，那么就不能改变这个对象的值。当const与引用相结合使用时，称为常引用。 常引用不能修改值 常引用可以与常量，变量（或字面值、表达式）绑定 如下代码所示，普通引用不能与常量绑定 const int a = 20; // int\u0026 ref = a; // 将int \u0026 类型的引用绑定到const int类型的初始值设定项时，限定符被丢弃 const int\u0026 ref = a; 💡常引用的作用 用这种方式声明的引用，不能通过引用对目标变量的值进行修改，达到了引用的安全性。 一旦完成声明，该引用的值就不再改变，即使被引用的变量已经发生了变化。** 用途：安全地进行函数传参 #include \u003ciostream\u003eusing namespace std; int main() { const int a = 20; // 将int\u0026 类型的引用绑定到const int类型的初始值设定项时 //限定符被丢弃 // int\u0026 ref = a; const int\u0026 ref1 = a; int x = 5, y = 4; const int\u0026 ref2 = (x+y); cout \u003c\u003c ref2 \u003c\u003c endl; y++; cout \u003c\u003c ref2 \u003c\u003c endl; // ref2++; // 表示式必须是可被修改的左值。 return 0; } // 9 // 9 // 10 // 9 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:7","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.8 函数与引用 C++把变量的引用作为函数形参，即传送变量的别名，具体略 函数的返回值为某一变量的引用，因此可对其返回值进行赋值操作 一般来说，函数不能作为左值，但如果将函数返回引用类型则可对其进行赋值 若要返回某个变量的引用，该变量必须存储在静态区，如全局变量或静态局部变量 注意：先调用，再赋值 #include \u003ciostream\u003eusing namespace std; int x = 20; int\u0026 add() { cout \u003c\u003c \"in add before inc x: \" \u003c\u003c x \u003c\u003c endl; x++; cout \u003c\u003c \"in add after inc x: \" \u003c\u003c x \u003c\u003c endl; return x; } int main() { cout \u003c\u003c add() \u003c\u003c endl; add() = -20; cout \u003c\u003c add() \u003c\u003c endl; return 0; } // in add before inc x: 20 // in add after inc x: 21 // 21 // in add before inc x: 21 // in add after inc x: 22 // in add before inc x: -20 // in add after inc x: -19 // -19 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:8","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.9 内联函数 编译时，将调用函数代码嵌入到主函数中，以空间效率换取时间效率 定义格式： inline \u003c函数值类型\u003e \u003c函数名\u003e(参数表){ } inline 关键字必须与函数定义体放在一起 内联函数必须充分简单，不含循环递归 一个好的编译器，会根据函数的函数体，自动取消不值得的内联 类内定义的成员函数会自动视为内联函数 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:9","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.10 字符串变量 字符串常量以**\\0**结束，但将字符串常量存放到字符串变量中时，只存放字符串本身而不包括'\\0' #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003ccstring\u003eusing namespace std; int main() { string str1, str2, str3; str1 = \"China\"; str2 = str1; str3 = str1 + str2; cout \u003c\u003c strlen(\"China\") \u003c\u003c endl; cout \u003c\u003c sizeof(\"China\") \u003c\u003c endl; cout \u003c\u003c str1.size() \u003c\u003c endl; } // 5 // 6 // 5 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:10","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["C++"],"content":"1.11 new/delete new操作从堆中分配一块与\u003c类型\u003e相适应的存储空间，而用int,float之类的申请的内存在栈中 \u003c指针变量名\u003e = new \u003c类型\u003e \u003c指针变量名\u003e = new \u003c类型\u003e(\u003c初值\u003e) \u003c指针变量名\u003e = new \u003c类型\u003e[\u003c元素个数\u003e] delete \u003c指针变量名\u003e delete[] \u003c指针变量名\u003e #include \u003ciostream\u003eusing namespace std; int main() { int* p = new int; cout \u003c\u003c p \u003c\u003c \" \" \u003c\u003c *p \u003c\u003c endl; int* q = new int(0); cout \u003c\u003c q \u003c\u003c \" \" \u003c\u003c *q \u003c\u003c endl; int* num = new int[20]; num[0] = 1; num[1] = 20; cout \u003c\u003c num[0] \u003c\u003c \" \" \u003c\u003c num[1] \u003c\u003c endl; delete(p); delete(q); delete(num); return 0; } // 0x1071780 17242864 // 0x10717a0 0 // 1 20 ","date":"2022-07-10","objectID":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/:1:11","tags":null,"title":"第一章 概述","uri":"/2022/07/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0/"},{"categories":["golang"],"content":"Golang优秀的GC机制，虽然可以让其不需要像C++中那样手动释放对象，从而避免内存泄漏，但goroutine的生命周期需要开发者格外注意。如果一个goroutine意外阻塞无法退出，就会造成goroutine泄漏的问题。随着占用的资源越来越多，只能重启服务器暂时缓解，还是得从根源上解决问题。本文对goroutine的泄漏场景进行了总结，是对煎鱼大佬博文的梳理，内容并非原创，参考原文已贴在末尾。 ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:0:0","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"0 泄漏原因 Goroutine内执行与channel或mutex有关的读写操作，由于长时间得不到响应阻塞。(2.1，2.2) Goroutine 内的业务逻辑进入长时间等待，有不断新增的 Goroutine 进入等待。(2.3) ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:1:0","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"1 排查方法 调用 runtime.NumGoroutine() 方法来获取 Goroutine 的运行数量 使用PProf工具 在实际生产过程中，更多的是使用PProf工具来进行分析是否发生了内存泄漏，具体请参考如下链接。 PProf工具使用 ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:2:0","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"2 泄漏场景 ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:3:0","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"2.1 通道使用不当 2.1.1 通道为nil package main import ( \"fmt\" \"runtime\" \"time\" ) func send(ch chan\u003c- int) { ch \u003c- 1 ch \u003c- 2 } func receive(ch \u003c-chan int) { \u003c-ch \u003c-ch } func main() { var ch chan int // 应修改为 ch := make(chan int) go send(ch) go receive(ch) time.Sleep(time.Second) fmt.Println(runtime.NumGoroutine()) } // 3 2.1.2 无人消费数据导致通道阻塞 package main import ( \"fmt\" \"runtime\" \"time\" ) func send(ch chan\u003c- int) { ch \u003c- 1 ch \u003c- 2 } func receive(ch \u003c-chan int) { \u003c-ch } func main() { ch := make(chan int) go send(ch) go receive(ch) time.Sleep(time.Second) fmt.Println(runtime.NumGoroutine()) } // 2 // send向通道中发送了两个值，但只被消费了一个 // 所以go send(ch)启动的协程被阻塞，结果会输出2 下面，使用pprof工具进行分析 package main import ( \"net/http\" _ \"net/http/pprof\" ) func send(ch chan\u003c- int) { ch \u003c- 1 ch \u003c- 2 } func receive(ch \u003c-chan int) { \u003c-ch } func pprofService() error { return http.ListenAndServe(\":6060\", nil) } func main() { done := make(chan error) ch := make(chan int) go func() { done \u003c- pprofService() }() for i := 0; i \u003c 100; i++ { go send(ch) } for i := 0; i \u003c 100; i++ { go receive(ch) } \u003c-done } // 按上述程序所示，启动100个send协程后，由于没法完全消费数据， // 所以造成goroutine的大量泄漏，其火焰图如下所示 PProf 火焰图\" PProf 火焰图 2.1.3 通道无法读取数据导致阻塞 package main import ( \"fmt\" \"runtime\" \"time\" ) func send(ch chan\u003c- int) { ch \u003c- 1 close(ch) } func receive(ch \u003c-chan int) { \u003c-ch \u003c-ch } func main() { ch := make(chan int) go send(ch) go receive(ch) time.Sleep(time.Second) fmt.Println(runtime.NumGoroutine()) } // 2 ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:3:1","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"2.2 互斥锁或同步锁使用不当 2.2.1 互斥锁使用不当 package main import ( \"fmt\" \"runtime\" \"sync\" \"time\" ) var counter int var mutex sync.Mutex func main() { for i := 0; i \u003c 5; i++ { go func() { mutex.Lock() // defer mutex.Unlock() counter++ }() } time.Sleep(time.Second) fmt.Println(runtime.NumGoroutine()) } // 5 // 第一个协程加锁之后没有解锁，counter++完之后直接退出 // 使得后面四个协程无法对counter加锁，从而造成阻塞 2.2.2 同步锁使用不当 package main import ( \"fmt\" \"sync\" ) func main() { var wg sync.WaitGroup for i := 0; i \u003c 5; i++ { wg.Add(6) go func(x int) { defer wg.Done() fmt.Println(\"goroutine: \", x) }(i) } wg.Wait() } // deadlock // 由于waitgroup使用不当，直接造成主协程阻塞（死锁） ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:3:2","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"2.3 奇怪的慢等待 func main() { for { go func() { _, err := http.Get(\"https://www.xxx.com/\") if err != nil { fmt.Printf(\"http.Get err: %v\\n\", err) } // do something... }() time.Sleep(time.Second * 1) fmt.Println(\"goroutines: \", runtime.NumGoroutine()) } } // http.Client默认没有设置超时时间 // 如果Get请求一直得不到满足，那么该协程就一直无法退出，从而造成泄漏 ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:3:3","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["golang"],"content":"3 参考资料 https://segmentfault.com/a/1190000040161853?utm_source=sf-similar-article https://www.php.cn/be/go/490491.html ","date":"2022-07-06","objectID":"/2022/07/goroutine-leak/:4:0","tags":["goroutine"],"title":"Goroutine 泄漏","uri":"/2022/07/goroutine-leak/"},{"categories":["git\u0026github"],"content":"使用Loveit主题的拓展short codes之后，由于在markdown之中引入了{{}}语法，使得Liquid在解析markdown中的代码块时出错，采用的解决方法是禁用Jekyll，因为hugo已经生成了静态站点所需的文件，不需要再使用Jekyll。在解决此问题的同时，学习于了解了Github上的Action功能，并使用Github Action完成了站点的自动部署。 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:0:0","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"0 前言 在未引入Github Action时，我部署在Github上的静态网站直接将Hugo生成的public目录直接上传至zchaoyu1126.github.io仓库中，然后自动触发pages build and deployment Action。等待一段时间后，就能通过访问zchaoyu1126.github.io查看效果。 但是，我在使用Loveit主题的拓展short codes之后，由于在markdown之中引入了{{}}语法，使得Liquid在解析markdown中的代码块时出错。 具体的原因，不是很清楚并没有深究。 Build with Jekyll 失败\" Build with Jekyll 失败 Liquid syntax error\" Liquid syntax error 为了解决本问题我做了一些探索，百般曲折过后，还是在官方文档中找到了解决办法。 官方文档中的说明\" 官方文档中的说明 禁用Jekyll有效的原因：hugo已经为我们生成了静态站点所需的文件，不需要再使用Jekyll。 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:1:0","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"1 Hugo的使用 Hugo的基础使用：https://www.gohugo.org/ ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:2:0","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2 使用Github Action部署Hugo 关于Github Action，请参考阮一峰老师的博客 以下内容参考：https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/ ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:0","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.1 建立仓库 首先在github上建立两个仓库， zchaoyu1126/zchaoyu1126.github.io：public目录的远端仓库（静态网页部署站点） zchaoyu1126/blog：hugo工作目录的远端仓库 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:1","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.2 .gitignore文件 在hugo的工作目录中新建一个.gitignore文件，从而将public文件夹排除在git仓库管理范围外。.gitignore内容如下， public/ ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:2","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.3 添加公钥和私钥 2.3.1 打开命令行，输入如下命令会在当前文件夹下生成一组密钥 ssh-keygen -t ed25519 -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" pub后缀为公钥，另一个为私钥 公钥与私钥\" 公钥与私钥 2.3.2 在zchaoyu1126/zchaoyu1126.github.io仓库中，点击Settings，添加Depoly keys 添加公钥\" 添加公钥 2.3.3 在zchaoyu1126/blog仓库中，点击Settings，添加Secrets 添加私钥\" 添加私钥 关于公钥密钥的解释 当我们在本地写完markdown文件之后向远程仓库提交，也就是zchaoyu1126/blog，远程仓库会自动触发Github Action，这个Action会自动向zchaoyu1126/zchaoyu1126.github.io仓库部署静态网站。这二者之间的安全交互便是通过这一组密钥。 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:3","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.4 禁用Jekyll 在zchaoyu1126/zchaoyu1126.github.io仓库中新建一个.nojekyll文件。其内容为空，表示禁用jekyll。 禁用Jekyll\" 禁用Jekyll 血泪史 事实证明，这种方法不可行，2.5中的部署过程中向github写数据时，会把原有的.nojekyll文件删掉。 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:4","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.5 添加Github Action 在zchaoyu1126/blog中新建一个Action，其内容如下： # ACTIONS_DEPLOY_KEY 根据自身情况进行修改，即2.3.3中输入的Name# EXTERNAL_REPOSITORY 根据自身情况进行修改name:GitHub Pages Deploy#自动化的名称on:push:# push的时候触发branches:# 那些分支需要触发- masterjobs:build:runs-on:ubuntu-latest# 镜像市场steps:- name:checkout# 步骤的名称uses:actions/checkout@master# 软件市场的名称with:# 参数submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.91.2'extended:true- name:Buildrun:hugo --minify- name:Forbid Jekyll # 由于2.4节的方法失效，所以在这里生成.nojekyll文件run:touch ./public/.nojekyll- name:Deployuses:peaceiris/actions-gh-pages@v2.5.1env:ACTIONS_DEPLOY_KEY:${{ secrets.ACTIONS_DEPLOY_KEY }}EXTERNAL_REPOSITORY:zchaoyu1126/zchaoyu1126.github.ioPUBLISH_BRANCH:masterPUBLISH_DIR:./public ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:5","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"2.6 Git Push 创建完Action之后，会执行一次push并触发action。 将本地的hugo目录同步至远程仓库(zchaoyu1126/blog)后，访问zchaoyu1126.github.io即可看到效果。 ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:3:6","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["git\u0026github"],"content":"3 参考资料 https://www.gohugo.org/ https://hugoloveit.com/zh-cn/theme-documentation-extended-shortcodes/ https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/ https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html https://docs.github.com/cn/pages/getting-started-with-github-pages/about-github-pages#static-site-generators ","date":"2022-06-29","objectID":"/2022/06/github-action-deploy-hugo/:4:0","tags":["github action","hugo","loveit"],"title":"使用Github Action自动部署Hugo","uri":"/2022/06/github-action-deploy-hugo/"},{"categories":["golang"],"content":"信息 以下1-5为字节青训营白嫖拿到的学习路线图 ","date":"2022-06-28","objectID":"/2022/06/means/:0:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"1 入门 官方课程Go语言圣经(中文版) Go by Example中文 Effective Go中文版本 标准库： Go语言标准库书籍 官方文档 官方文档翻译 其他： Go学习笔记 The way to go Go语言101 Go语言入门教程 Go命令教程 Go并发编程实战 Golang-100天从新手到大师 ","date":"2022-06-28","objectID":"/2022/06/means/:1:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"2 进阶 7天用Go从零实现系列 Web RPC生态 Go Web编程 Go RPC 开发指南 Go Web Examples DB/ORM: https://gorm.io/docs/ https://pkg.go.dev/gorm.io/gorm# 高性能编程 原理、设计实现： Go语言设计与实现 Go语言原本 Go语言高级编程 Go专家编程 深入解析Go Go Assembly 示例 ","date":"2022-06-28","objectID":"/2022/06/means/:2:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"3 社区 Golang中国 StudyGolang ","date":"2022-06-28","objectID":"/2022/06/means/:3:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"4 资料索引 Go-IT技术知识开源图谱 Go语言学习资料与社区索引 Go知识图谱（快速了解各领域主流开发框架） go-awesome awesome-go Go进阶训练营 课程大纲 ","date":"2022-06-28","objectID":"/2022/06/means/:4:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"5 学习建议 选择一本入门书籍，系统了解语法 快速过一遍标准库，直到常见标准库的用法 过一遍各种资料索引，awesome list，了解Go语言各种领域生态 跟着一些实践课程，基于主流框架试着做一些小型项目 ","date":"2022-06-28","objectID":"/2022/06/means/:5:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["golang"],"content":"6 补充 资料索引：https://learnku.com/go/docs 李文周的博客：https://www.liwenzhou.com/posts/Go/golang-menu/ 公众号：脑子进煎鱼了，网管叨bi叨，Kratos开源社区 项目：https://juejin.cn/post/7038967716459315208 煎鱼 (eddycjy.com) Go修养之路：https://www.yuque.com/aceld/golang ","date":"2022-06-28","objectID":"/2022/06/means/:6:0","tags":null,"title":"Go语言学习资料","uri":"/2022/06/means/"},{"categories":["计算机网络"],"content":"1 IPv4 地址 IPv4地址是一个32bit地址，唯一地与通用地定义了一个连接在因特网上的设备。IP地址采用点分十进制记法，首先每8个Bit插入一个空格，然后将每8bit的二进制数转换为十进制数。 警告 不能有先导0，数值均小于等于255且大于等于0 IP地址现由ICANN（Internet Corporation for Assigned Names and Numbers）进行分配。 IP地址管理机构在分配IP地址时，只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。 路由器仅根据目的主机所连接的网络号来转发分组（而不考虑其主机号），这样可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 IP地址的编址方法总共经历了三个阶段 分类的IP地址：这是最基本的编址方法，在1981年就通过了相应的标准协议。 子网的划分：这是最基本编址方法的改进，其标准RFC 950在1985年通过。 构成超网：这是比较新的无分类编址方法。在1993年提出后很快得到推广应用。 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:1:0","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"1.1 分类的IP地址 1.1.1 IP地址分类 通过net-id和host-id将IP地址空间被划分为ABCDE五类，其中D类为多播地址，E类为保留地址。 IP地址的分类\" IP地址的分类 信息 为什么要分离网络号和主机号？ 因为两台计算机要通讯，首先要判断是否在同一个广播域内，即网络地址是否相同。如果网络地址相同，表示接受发在本网络上，那么可以把数据报直接发送到目标主机。路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。 1.1.2 特殊IP地址 在IP地址中有一些并不是来标注主机的，这些地址具有特殊的意义。 这些地址包括网络地址、直接广播地址、受限广播地址、本网络地址、环回地址等。 ①网络地址 {\u003cnet-id\u003e，0 }：用于标识网络 因特网上的每个网络都有一个IP地址，其主机号部分为0。 A类网络的网络地址为：Network-number.0.0.0。例如，120.0.0.0； B类网络的网络地址为：Network-number.0.0。例如，139.22.0.0； C类网络的网络地址为：Network-number.0。例如，203.120.16.0。 信息 用于标识网络，不能分配给主机，故不能作为数据的源地址和目的地址。 ②直接广播地址 {\u003cnet-id\u003e，-1}：向某个网络上所有的主机发送报文。 TCP/IP规定，主机号各位全部为“1”的IP地址用于广播，叫作广播地址。路由器在目标网络处将直接广播地址映射为物理网络的广播地址，例如将其映射为6个字节全为1的以太网广播地址。 A类网络的直接广播地址为：Network-number.255.255.255。例如，120.255.255.255； B类网络的直接广播地址为：Network-number.255.255。例如，139.22.255.255； C类网络的直接广播地址为：Network-number.255。例如，203.120.16.255。 信息 直接广播地址只能作为目的地址 ③受限广播地址{-1，-1}：在本网络内部进行广播。 受限广播地址是在本网络内部进行广播的一种广播地址，TCP/IP规定，32位比特全为“1”的IP地址用于本网络内的广播。 直接广播要求发送方必须知道目标网络的网络号，但有些主机在启动时往往并不知道本网络的网络号，这时候如果想要向本网络广播，只能采用受限广播地址（Limited Broadcast Address）。 信息 受限广播地址只能作为目的地址。 路由器隔离受限广播，不对受限广播分组进行转发。也就是说因特网不支持全网络范围的广播。 TCP/IP协议规定，网络号各位全部为“0”时表示的是本网络。本网络地址分为两种情况：本网络特定主机地址和本网络本主机地址。 ④本网络特定主机地址{0，\u003chost-id\u003e} 信息 本网络特定主机地址只能作为源地址。 ⑤本网络本主机地址{0，0} 无盘工作站启动时没有IP地址，此时采用网络号和主机号都为“0”的本网络本主机地址作为源地址。 信息 本网络本主机地址只能作为源地址。 ⑥环回地址{127, \u003cany\u003e}：用于网络软件测试以及本机进程之间通信的特殊地址 习惯上采用127.0.0.1作为环回地址，命名为localhost。当使用环回地址作为目标地址发送数据时，数据将不会被发送到网络上，而是在数据离开网络层时将其回送给本机的有关进程。 环回接口对IP数据报的处理过程，如下图所示： 环回地址\" 环回地址 在发送IP数据时，首先要判别该数据报的目的IP地址是否为环回地址，如果是环回地址，则直接将IP数据报放入IP输入队列实现环回。对于直接以本机地址作为目的地址的IP数据包也要会送给本机。对于广播或组播数据报，则在会送给本机的同时还要向网络发送。 在除去特殊IP地址之后，可使用的IP地址如下， IP地址可使用范围\" IP地址可使用范围 1.1.3 私有网络 在IP地址空间中，保留了几个用于私有网络的地址，私有网络地址通常应用于公司、组织和个人网络，它们没有置于因特网。 A类：10.0.0.0~10.255.255.255 B类：172.16.0.0~172.31.255.255 C类：192.168.0.0~192.168.255.255 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:1:1","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"1.2 划分子网 问题 对于某些中等规模的网络，一个C类的IP地址不够用，而使用B类的IP地址则过于浪费。如果使用多个C类地址则会造成一个组织有多个网络域，这会导致路由器的路由表扩大。 在ARPANET早期，IP地址的设计不够合理，使得IP地址空间的利用率很低，而且给每个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。从1985年起，在IP地址中又增加了一个子网号字段，使两级的IP地址变成了三级的IP地址。这种做法叫做划分子网，划分子网已经称为因特网的正式标准协议。 1.2.1 子网的划分 划分子网属于一个单位（net-id）内部的事情，该单位（net-id）对外仍然表现为没有划分子网的网络。 划分子网的方式：从主机号中借用若干个比特作为子网号subnet-id，由此ip地址变为 {\u003cnet-id\u003e，\u003csubnet-id\u003e，\u003chost-id\u003e}这样的三级形式。 1.2.2 变长网络掩码 为了在一个划分子网的网络中可以同时使用几个不同的子网掩码，提出了变长子网掩码（Variable Length Subnet Mask，VLSM）进一步提高IP地址资源的利用率。 VLSM\" VLSM 假设有一个组织的网络规模可以使用一个C类地址范围，且需要分为4个子网，那么使用定长的掩码，则至少需要将子网掩码设置为255.255.255.192，这样这个组织的C类地址就被分成了4个等大小的子网，每个子网有62个可用地址。但事实上子网A有100台主机和设备，子网B有50台，子网C、D各有20多台，此时就无法满足需求。 若使用VLSM技术，则可以设计192.168.1.0/25（126），192.168.1.0/26（62），192.168.1.0/27（30），192.168.1.0/27（30）的子网掩码。 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:1:2","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"1.3 构成超网 问题 虽然使用子网技术可以是IP地址都得到有效的应用，但还是很难防止IP地址资源耗尽，因为任何一个规模超过256的网络都需要使用B类地址，所以B类地址消耗的速度特别快，而C类地址缺得不到应用。解决这个问题的一个方法是消除IP地址中类别的概念。 在VLSM的基础上，又进一步研究出无分类编址方法，它的正式名字使无分类域间路由选择CIDR（Classless Inter-Domain Routing)。 CIDR技术将子网标识的两个部分直接合并到一起，使三级的IP地址又变回了两级{\u003cnet-prefix\u003e，\u003chost-id\u003e}，net-prefix为网络前缀。 CIDR仍使用斜线记法，例如128.14.32.0/20，表示该网络一共能容纳$2^{12}-2$个主机或设备。 原有的IP地址分类方法，使得一个C类地址的网络，最多拥有256个IP地址，而使用CIDR之后致力于消除分类的概念，可以使原先多个C类地址合成为一个规模更大的地址范围，从而提高IP地址的利用率。 具体地，可见如下例子， CIDR\" CIDR ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:1:3","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"1.4 寻址 IP地址的网络地址（\u003cnet-id\u003e，0）用于路由控制中。 在主机和路由器上都会有各自的路由表，如果是windows，可以使用route print命令查看。 在路由表中记录着网络地址与下一步应该发送至路由器的位置。 在发送IP数据包时，首先会确定IP包首部中的目标地址，判断是否在同一网络中，若是则直接转发。否则去路由表中查找与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。 如下图所示，凡是从其他网络发送到本单位某个主机的IP数据，仍然是根据IP数据报的net-id先找到连接在本单位网络上的路由器。然后此路由器在收到IP数据报之后，再按net-id和subnet-id找到目的子网，最后将IP数据报交付给目的主机。 子网的划分\" 子网的划分 路由器R1使用存储的子网掩码与目标IP地址相与，如果得到的结果与目的网络地址相同，那么说明该子网就是目标网络。 路由器寻找路径\" 路由器寻找路径 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:1:4","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"2 IPv6 持续更新中 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:2:0","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"3 NAT地址映射 持续更新中 NAT1\" NAT1 NAT2\" NAT2 NAT3\" NAT3 NAT4\" NAT4 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:3:0","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"4 ISP技术 ISP\" ISP ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:4:0","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["计算机网络"],"content":"5 参考资料 https://blog.csdn.net/qq_38410730/article/details/80980749 https://xiaolincoding.com/network/4_ip/ip_base.html 西电计算机网络课程PPT 本文仅IP的相关知识点进行摘录，文中所有图片著作权归原作者所有，如有侵权请联系删除。 ","date":"2022-05-30","objectID":"/2022/05/network-ch4/:5:0","tags":null,"title":"ch4 网络层-IP基础","uri":"/2022/05/network-ch4/"},{"categories":["golang"],"content":"ch23 同步 Go程序可以使用通道进行多个goroutine之间的数据交换，但这仅仅是数据同步中的一种方法。在一些轻量级的场合可以使用atomic，sync.Mutex以及等待组sync.WaitGroup。 ","date":"2022-03-16","objectID":"/2022/03/go-ch23/:0:0","tags":null,"title":"Ch23 同步","uri":"/2022/03/go-ch23/"},{"categories":["golang"],"content":"竞态检测 当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞态问题。 package main import ( \"fmt\" \"sync/atomic\" ) var seq int64 func main() { for i := 0; i \u003c 10; i++ { go GenID() } fmt.Println(GenID()) } func GenID() int64 { atomic.AddInt64(\u0026seq, 1) return seq } 使用原子操作函数atomic.AddInt64()对seq进行加1操作，但是在这里故意没有使用atomic.AddInt64()的返回值作为GenID()的返回值，所以会造成一个竞态问题。 编译运行时，加入-race参数，即go run -race main.go 会发生宕机错误，提示信息为Warning: DATA RACE 应修改为 func GenID() int64 { return atomic.AddInt64(\u0026seq, 1) } ","date":"2022-03-16","objectID":"/2022/03/go-ch23/:1:0","tags":null,"title":"Ch23 同步","uri":"/2022/03/go-ch23/"},{"categories":["golang"],"content":"互斥锁 atomic: 对变量进行原子操作 sync.Mutex: 对一段代码加上互斥锁，对共享内存进行保护 package main import ( \"fmt\" \"sync\" ) var count int var countGuard sync.Mutex func GetCount() int { countGuard.Lock() defer countGuard.Unlock() return count } func SetCount(x int) { countGuard.Lock() count = x countGuard.Unlock() } func main() { SetCount(1) fmt.Println(GetCount()) } 一般情况下，建议将互斥锁的粒度设置的越小越好，从而降低因为共享访问时等待的时间。 一旦发生加锁，如果另外一个goroutine尝试继续加锁则会发生阻塞，直到这个countGuard被解锁。 package main import ( \"fmt\" \"sync\" \"time\" ) var count int var countGuard sync.Mutex func GetCount() int { countGuard.Lock() defer countGuard.Unlock() return count } func SetCount(x int) { countGuard.Lock() time.Sleep(time.Second * 5) count = x countGuard.Unlock() } func main() { go func() { SetCount(5) }() go func() { fmt.Println(\"waitting...\") fmt.Println(GetCount()) }() var quit int fmt.Scan(\u0026quit) } ","date":"2022-03-16","objectID":"/2022/03/go-ch23/:2:0","tags":null,"title":"Ch23 同步","uri":"/2022/03/go-ch23/"},{"categories":["golang"],"content":"读写互斥锁 在读多写少的环境中，可以优先使用读写互斥锁。 GetCount(1)这个gorouine睡眠了5秒，在这5秒内并没有释放读锁，而执行GetCount(0)的goroutine并没有受此影响而阻塞。 package main import ( \"fmt\" \"sync\" \"time\" ) var count int var countGuard sync.RWMutex func GetCount(opt int) int { countGuard.RLock() if opt == 1 { time.Sleep(time.Second * 5) } defer countGuard.RUnlock() return count } func SetCount(x int) { countGuard.Lock() count = x countGuard.Unlock() } func main() { go func() { fmt.Println(1, GetCount(1)) }() go func() { fmt.Println(0, GetCount(0)) }() var quit int fmt.Scan(\u0026quit) } ","date":"2022-03-16","objectID":"/2022/03/go-ch23/:3:0","tags":null,"title":"Ch23 同步","uri":"/2022/03/go-ch23/"},{"categories":["golang"],"content":"等待组 (wg *WaitGroup) Add(delta int) 等待组的计数器+delta (wg *WaitGroup) Done() 等待组的计数器-1 (wg *WaitGroup) Wait() 当等待器计数器不等于0时阻塞直到变成0 package main import ( \"fmt\" \"net/http\" \"sync\" ) func main() { var wg sync.WaitGroup urls := []string{ \"https://www.github.com/\", \"https://www.qiniu.com\", \"https://www.golangtc.gom\", } for _, url := range urls { wg.Add(1) go func(url string) { defer wg.Done() _, err := http.Get(url) fmt.Println(url, err) }(url) // 这样是不允许的，url会一直改变，导致请求的网址都是同一个 // go func() { // defer wg.Done() // _, err := http.Get(url) // fmt.Println(url, err) // }() } wg.Wait() fmt.Println(\"over\") } ","date":"2022-03-16","objectID":"/2022/03/go-ch23/:4:0","tags":null,"title":"Ch23 同步","uri":"/2022/03/go-ch23/"},{"categories":["golang"],"content":"ch21 协程 Go语言的并发通过goroutine特性完成。goroutine类似于线程，但是可以根据需要创建多个goroutine并发工作。 goroutine是由Go语言的运行时调度完成，而线程则是由操作系统调度完成。 Go语言提供channel以便于在多个goroutine间进行通信。 goroutine和channel是Go语言秉承的CSP（Communicating Sequential Process)并发模式的重要实现基础。 Go程序从main包的main函数开始，在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。 ","date":"2022-03-10","objectID":"/2022/03/go-ch21/:0:0","tags":null,"title":"Ch21 协程","uri":"/2022/03/go-ch21/"},{"categories":["golang"],"content":"创建goroutine Go程序中使用go关键字为一个函数创建一个goroutine，一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数。 go functionName(params type) 注：返回值会被忽略，如果要通信，使用channel package main import ( \"fmt\" \"time\" ) func running() { var times int for { times++ fmt.Println(\"tick\", times) time.Sleep(time.Second) } } func main() { go running() var input string fmt.Scanln(\u0026input) } 使用go running()之后，会创建一个协程，每个一秒输出一个tick，在用户的输入读取完毕后，整个程序结束，goroutine被终止。 Go程序在启动时，runtime会默认为main()函数创建一个goroutine，main()函数的goroutine中执行到go running()语句时，归属于running()函数的goroutine被创建，running()函数开始在自己的goroutine中执行，此时，main()函数继续执行，两个goroutine通过GO程序的调度机制同时运行。 ","date":"2022-03-10","objectID":"/2022/03/go-ch21/:1:0","tags":null,"title":"Ch21 协程","uri":"/2022/03/go-ch21/"},{"categories":["golang"],"content":"匿名函数创建goroutine package main import ( \"fmt\" \"time\" ) func main() { go func() { var times int for { times++ fmt.Println(\"ticks\", times) time.Sleep(time.Second) } }() var input string fmt.Scanln(\u0026input) } 注意事项： 所有goroutine在main()函数结束时会一同结束 goroutine的调度依赖于调度器的实现和运行环境 golang无法kill 一个 goroutine，但可以通过一个chan给它发送消息让它退出，更多的信息见 ch25 并发编程 使用通道让goroutine退出的示例如下 package main import ( \"fmt\" \"time\" ) func main() { exist := make(chan int) go func(exist chan int) { for { select { case \u003c-time.After(time.Second): fmt.Println(\"hi\") case \u003c-exist: goto End } } End: fmt.Println(\"finished\") }(exist) time.Sleep(time.Second * 5) exist \u003c- 2 time.Sleep(time.Second * 2) } ","date":"2022-03-10","objectID":"/2022/03/go-ch21/:2:0","tags":null,"title":"Ch21 协程","uri":"/2022/03/go-ch21/"},{"categories":["golang"],"content":"调整并发的运行性能 Go程序运行时(runtime)实现了一个小型的任务调度器，这套调度器的工作原理类似于操作系统调度线程，Go程序调度器可以高效地将CPU资源分配给每一个任务。 传统逻辑中，开发者需要维护线程池中线程与CPU核心数量的对应关系。同样的，Go中可以通过设置runtime.GOMAXPROCS()函数做到，runtime.GOMAXPROCS(runtime.NumCPU()) ch40 goroutine调度机制 ","date":"2022-03-10","objectID":"/2022/03/go-ch21/:3:0","tags":null,"title":"Ch21 协程","uri":"/2022/03/go-ch21/"},{"categories":["golang"],"content":"ch22 通道 单纯地将函数并发执行是没有意义的，函数与函数间需要交换数据才能体现并发执行函数的意义。使用共享内存在不同的goroutine中容易发生竞态问题，为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Go提倡使用通信来共享内存，而不是用共享内存来通信。 ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:0:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"通道的特性 Go语言中的通道是一种特殊的类型，在任何时候，同时只能有一个goroutine访问通道进行发送和获取数据。 总是遵循先进先出的规则，保证收发数据的顺序。 ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:1:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"声明与创建 通道是引用类型，空值为nil，需要结合make使用 var 通道变量 chan 通道类型 ch1 := make(chan int) ch2 := make(chan interface{}) ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:2:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"发送与接收数据 ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:3:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"发送数据 把数据往通道中发送时，如果对方一直没有接收，那么发送操作将持续阻塞。 package main func main() { ch := make(chan int) ch \u003c- 0 } // fatal error: all goroutines are asleep - deadlock! ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:3:1","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"接收数据 通道接收同样使用\u003c- 每次只能接收一个元素 通道的收发操作在两个不同的goroutine间进行 由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定是在另外一个goroutine中进行。 接收方将持续阻塞直到发送方发送数据 data := \u003c-ch package main import \"time\" import \"fmt\" func main() { ch := make(chan int) go func() { time.Sleep(time.Second*5) fmt.Println(\"开始发送\") ch \u003c- 20 }() data := \u003c- ch fmt.Println(\"接收完毕, 数据为\", data) } ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:3:2","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"循环接收数据 通道的数据接收可以借用for range语句进行多个元素的接收操作，格式如下： for data := range ch { } 使用range读取channel值时，若chan没有关闭或者手动break，则会一直等待channel的值，并且阻塞后面语句的执行。两个例子如下 例1 package main import \"fmt\" func main() { ch := make(chan int) go func() { for i := 3; i \u003e= 0; i-- { ch \u003c- i } }() for data := range ch { fmt.Println(data) if data == 0 { break } } } 例2 package main import \"fmt\" import \"time\" func main() { ch := make(chan int) go func() { for v := range ch { fmt.Println(v) } fmt.Println(\"over\") } () fmt.Println(\"main start\") time.Sleep(time.Second*2) ch \u003c- 2 time.Sleep(time.Second*3) fmt.Println(\"main over\") } ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:3:3","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"通道用于并发同步 这里的通道相当于信号量的作用，当goroutine结束之后，通知main函数的goroutine，然后main函数所以的goroutine被唤醒，继续执行。 package main import \"fmt\" func main() { ch := make(chan int) go func() { func.Println(\"start goroutine\") // do something fmt.Println(\"exit goroutine\") ch \u003c- 0 }() fmt.Println(\"wait goroutine\") \u003c- ch // do something fmt.Println(\"all done\") } quit := make(chan bool) go func() { for { select { case \u003c- quit: return default: // Do other stuff } } }() // Do stuff // Quit goroutine close(quit) ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:4:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"单向通道 Go的通道可以在声明时约束其操作方向，如只是发送或者只是接收。这种被约束方向的通道被称作单向通道。单向通道有利于代码接口的严谨性。 只能发送的通道类型为chan\u003c-，只能接收的通道类型为\u003c-chan，格式如下 var 通道实例 chan\u003c- 元素类型 var 通道实例 \u003c-chan 元素类型 ch1 := make(chan int) var chSendOnly chan\u003c- int = ch1 var chRecvOnly \u003c-chan int = ch1 ch2 := make(\u003c-chan int) ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:5:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"带缓冲的通道 在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。 带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满是才会发生阻塞。同时，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。 无缓冲通道其实可以看作长度永远为0的带缓冲通道。 ch := make(chan int, 3) ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:6:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"通道的多路复用 多路复用时通信和网络中的一个专业术语，多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。报话机同一时刻，只有一边进行收或者发的单边通信，而电话可以在说话的同时听到对方说完毕，类似的还有网线、光纤等。 Go语言中提供了select关键字，可以让使用通道完成多路复用，也就是说，同时响应多个通道的操作。select中的每个case都响应一个通道的收发过程。当收发完成时，就会触发case中响应的语句。多个操作在每次select中挑选一个进行响应。 select { case 操作1： 响应操作1 case 操作2: 响应操作2 ... default: 操作 } 示例1：模拟远程过程调用 package main import ( \"errors\" \"fmt\" \"time\" ) func main() { ch := make(chan string) go RPCServer(ch) recv, err := RPCClient(ch, \"hi\") if err != nil { fmt.Println(err) } else { fmt.Println(recv) } } func RPCServer(ch chan string) { for { data := \u003c-ch fmt.Println(\"server received data:\", data) ch \u003c- \"roger\" } } func RPCClient(ch chan string, req string) (string, error) { ch \u003c- req select { case ack := \u003c-ch: return ack, nil case \u003c-time.After(time.Second): return \"\", errors.New(\"time out\") } } 示例2：计时器与通道的应用1 package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) ch2 := make(chan int) go func(ch chan int) { time.Sleep(time.Second * 2) ch \u003c- 2 }(ch1) go func(ch chan int) { time.Sleep(time.Second * 3) ch \u003c- 3 }(ch2) select { case val := \u003c-ch1: fmt.Println(val) case val := \u003c-ch2: fmt.Println(val) case \u003c-time.After(time.Second): fmt.Println(\"Time out\") default: fmt.Println(\"none\") } } // none // 没有default分支，输出Time out 示例3：计时器与通道的应用2 ticker，打点计时器 timer，计时器 计时任务的同步实现方式，因为select响应一次之后就会结束，所以得使用for循环，但是使用break无法退出外层循环，故使用goto 与 label。 package main import ( \"fmt\" \"time\" ) func main() { ticker := time.NewTicker(time.Millisecond * 500) stopper := time.NewTimer(time.Second * 2) var i int for { select { case \u003c-ticker.C: i++ fmt.Println(\"tick\", i) case \u003c-stopper.C: goto StopHere } } StopHere: fmt.Println(\"done\") } 示例4：计时器与通道的应用3 计时任务的异步执行方式，time.AfterFunc()中注册了一个回调函数，回调函数中通过通道发送已经完成任务的信号 package main import ( \"time\" ) func main() { exit := make(chan int) time.AfterFunc(time.Second, func() { exit \u003c- 1 }) \u003c-exit } ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:7:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"通道的关闭 chan关闭时机：调用close(ch)且其中的数据全部被消费，或者主线程关闭。 被关闭的通道ch，并不会立刻被GC回收，并且不会被置为nil，但无法向其发送数据 package main import ( \"fmt\" ) func main() { ch := make(chan int, 3) ch \u003c- 1 ch \u003c- 2 close(ch) fmt.Println(cap(ch), len(ch)) ch \u003c- 3 } // 3 2 // panic: send on closed channel 从已经关闭的通道接收数据不会阻塞，如果ch没有close，则for range会阻塞 package main import ( \"fmt\" ) func main() { ch := make(chan int, 3) ch \u003c- 1 ch \u003c- 2 close(ch) for i := range ch { fmt.Println(i) } val, ok := \u003c-ch fmt.Println(val, ok) // 向已关闭，且无数据的通道继续读取数据，不会发生阻塞，但返回值为零值和false } // 1 // 2 // 0 false ","date":"2022-03-10","objectID":"/2022/03/go-ch22/:8:0","tags":null,"title":"Ch22 通道","uri":"/2022/03/go-ch22/"},{"categories":["golang"],"content":"ch20 map ch38 map底层实现 写在前面，map并不是并发安全的，如果需要在goroutine中使用，需要使用sync.map，更多的信息请参考 ch25 并发编程 ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:0:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"定义与初始化 先定义后初始化 // 定义map // var mp map[KeyType]ValueType var mp map[string]int // 在未初始化时,mp无法使用，否则会宕机 mp = make(map[string]int) // 或者用如下方式 mp = map[string]int{} 定义并初始化 mp1 := make(map[string]int) mp2 := map[string]int{} mp3 := map[string]int{ \"apple\":2, \"banana\":3, } ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:1:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"根据key查询value 如果key不存在时，会返回value对应类型的默认值，但不能区分返回的”零值”是真实数据还是默认值，所以常需要按照如下的方式进行查询 func main() { scores := make(map[string][]int) name := \"Lily\" n := 5 if val, has := scores[name]; !has { // 不存在Lily的成绩记录，所以首先创建一个[]int scores[name] = make([]int, n) } // 如果直接执行下面这两行会因为scores[name]对应的是一个nil指针，而触发宕机错误 scores[name][0] = 90 scores[name][1] = 94 ... } ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:2:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"遍历map for k, v := range mp { fmt.Println(k, v) } for _, v := range mp { fmt.Println(v) } for k := range mp { fmt.Println(k) } package main import \"fmt\" func main() { mp := map[string]int{\"Lily\": 90, \"Tom\": 94} // 注意for range val是一个拷贝 for _, val := range mp { val = 20 fmt.Println(val) } for key, val := range mp { fmt.Println(key, val) } } 注：遍历输出的元素与填充顺序无关，不能期望map在遍历时返回某种期望顺序的结果。 ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:3:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"删除键值对 使用delete内建函数从map中删除一组键值对，delete()函数的格式为delete(mp，key) package main import \"fmt\" func main() { scene := make(map[string]int) scene[\"route\"] = 66 scene[\"brazil\"] = 4 scene[\"china\"] = 960 delete(scene, \"brazil\") for k, v := range scene { fmt.Println(k, v) } } ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:4:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"清空map中的元素 Go语言并没有为map提供任何清空所有元素的函数、方法。 清空map的唯一办法就是重新make一个新的map。垃圾回收的效率比写一个清空函数的效率高。 ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:5:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"sync.Map Go中的map在并发时，只读是线程安全的，同时读写线程不安全。 package main func main() { m := make(map[int]int) go func() { for { m[1] = 1 } }() go func() { for { _ = m[1] } }() select {} } // 运行时输出: fatal error: concurrent map read and map write Go在1.9版本中提供了一种效率较高的并发安全的sync.Map https://golangforall.com/en/post/sync-map.html 无需初始化，直接声明即可 sync.Map不能使用map的方式进行取值和设置等操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值。Range参数中的回调函数的返回值功能是：需要继续迭代遍历时，返回true，终止迭代遍历时，返回false。 package main import ( \"fmt\" \"sync\" ) func main() { var scene sync.Map scene.Store(\"greece\", 97) scene.Store(\"london\", 100) scene.Store(\"egypt\", 200) fmt.Println(scene.Load(\"london\")) scene.Delete(\"london\") scene.Range(func(key interface{}, value interface{}) bool { fmt.Println(\"iterate:\", key, value) return true }) } ","date":"2022-03-05","objectID":"/2022/03/go-ch20/:6:0","tags":null,"title":"Ch20 接口","uri":"/2022/03/go-ch20/"},{"categories":["golang"],"content":"ch19 接口 传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统功能的不断增加，这棵“派生树”会变得越来越复杂。 对于Go语言来说，非侵入式设计让实现者的所有类型都是平行的、组合的。如何组合则留到使用者编译时再确认，因此使用Go语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么”，以及“我能实现什么“。 接口的实现原理https://www.jianshu.com/p/70003e0f49d1 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:0:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"声明接口 接口是一种约定，它是一个抽象的类型，与见到的具体的类型如int、map、slice等不一样。 具体的类型，可以知道它是什么，并且可以知道可以用它做什么；但是接口不一样，接口是抽象的，它只有一组接口方法，并不知道它的内部实现，虽然不知道接口是什么，但是知道可以利用它提供的方法做什么。 通过如下格式定义接口，其中Namer就是一个接口类型 type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ... } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:1:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"命名规范 按照约定，接口的名字有方法名加[e]r后缀组成，例如Printer，Reader、Writer、Logger、Converter等等。还有一些不常用的方式（当后缀er不合适时），比如Recoverable，此时接口名以able结尾，或者以I开头 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:2:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"接口类型的实现 接口是一个抽象类型，用来定义行为的类型，但这些定义的行为不是由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型，实现了接口类型声明的所有方法，那么这个用户定义的类型就实现了这个接口，称实现了某一接口的类型为实体类型，该实体类型的值可以赋值给接口类型的值。 如上所述，如果要实现一个接口必须实现这个接口提供的所有方法。具体实现时，实体类型可以采用值接收者或指针接收者两种方式实现接口中定义的方法，但这两种方式是有区别的，具体如下。 值接收者实现 package main import \"fmt\" type animal interface{ printInfo() } type cat struct { name string age int } func main(){ c := cat { name : \"mimi\", age : 5, } var a animal = c invoke(a) } // 类型cat使用值接收者实现接口中定义的方法 func (c cat) printInfo(){ fmt.Printf(\"this cat's name is %s and it's age is %d\\n\", c.name, c.age) } func invoke(a animal) { a.printInfo() } invoke函数接收一个animal接口类型，例子中传递参数的时候，也是以类型cat的值c传递的，运行程序可以正常执行。现在稍微改造一下，将*cat类型赋值给animal a，并作为参数传递。 func main(){ c := \u0026cat { name : \"mimi\", age : 5, } var a animal = c invoke(a) } 运行程序，发现程序可以正常运行。 实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都被认为实现了该接口。 指针接收者实现 func main(){ c := cat { name : \"mimi\", age : 5, } var a animal = c invoke(a) } // 类型cat使用指针接收者实现接口中定义的方法 func (c *cat) printInfo(){ fmt.Printf(\"this cat's name is %s and it's age is %d\\n\", c.name, c.age) // c.name == (*c).name, c.age == (*c.age) } 此时编译器已经提示cat没有实现animal接口，因为printInfo方法是指针接收者，所以值c不能作为接口类型animal传参使用。若修改为var a animal = \u0026c，则运行成功。 实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了这个接口。 Go 语言规范定义了接口方法集的调用规则： 类型 T 的可调用方法集包含接受者为 T 的所有方法，不包含接受者为* T 的方法 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:3:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"内部实现 Go语言中的接口可以有值，一个接口类型的变量或一个接口值，例如var ai Namer，ai是一个多字数据结构，它的初始值是nil 实现了Namer接口的类型的变量可以赋值给ai(即receiver的值)，方法表指针（method table ptr)就指向了当前的方法实现。当另一个实现了Namer接口的类型的变量被赋给ai时，receiver的值和方法表指针也会相应改变。 func main(){ var b bytes.Buffer fmt.Fprint(\u0026b, \"hello world\") var w io.Writer w = \u0026b fmt.Println(w) } 这里例子中，因为bytes.Buffer实现了接口io.Writer，所以可以通过w=\u0026b对w进行赋值。这个赋值的操作会把定义类型的值存入接口类型的值。 接口的值被赋值后，接口值内部的布局。接口的值是一个两个字长度的数据结构，第一个字包含一个指向内部表结构的指针，这个内部表里存储的有实体类型的信息以及相关联的方法集；第二个字包含的是一个指向存储的实体类型值的指针。 所以接口的值结构其实是两个指针，这也可以说明接口其实是一个引用类型。 ch39 interface底层实现 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:4:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"特性 多个类型可以实现一个接口 一个类型可以实现多个接口 实现某个接口的类型除了实现接口方法外，可以有其他的办法 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:5:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"接口嵌套组合 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。 比如File中包含了ReadWriter和Locker的所有方法，还额外有一个Close()方法 type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Locker interface { Lock() UnLock() } type File interface { ReadWrite Locker Close() } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:6:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"类型断言 一个接口类型的变量varI中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型。 在执行过程中动态类型可能会有所不同，通常可以使用类型断言来测试在某个时刻varI是否包含类型T的值。 varI必须是一个接口变量，否则编译器会报错 if v, ok := varI.(T); ok { Process(v) return } 如果转换合法，v是varI转换到类型T的值，ok会是true；否则v是类型T的零值，ok是false。 package main import \"fmt\" type Shaper interface { Area() } type Circle struct { radius float32 } func main() { var area Shaper area = \u0026Circle{radius:3} if t, ok := area.(*Circle); ok { fmt.Printf(\"The type of areaIntf is: %T\\n\", t) } } func (c *Circle) Area(){ fmt.Println(\"circle's area\") } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:7:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"type-switch结构 接口变量的类型也可以使用一种特殊形式的switch来检测 此外，在处理来自于外部的、类型未知的数据时，比如解析诸如JSNO或XML编码的数据时，类型测试和转换会非常有用 switch x.(type) { case bool: // do something case int: // do something default: //do something } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:7:1","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"常见接口 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:8:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"Sort接口 type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:8:1","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"读写接口 读和写是软件中很普遍的行为，提起它们就会立即想到读写文件、缓存（比如字节或字符串切片）、标准输入输出、标准错误以及网络连接、管道等，或者读写我们的自定义类型。为了让代码尽可能通用，GO采取了一致的方式来读写数据。 io包提供了用于读和写的接口io.Reader和io.Writer type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } 只要类型实现了读写接口，提供 Read() 和 Write 方法，就可以从它读取数据，或向它写入数据。一个对象要是可读的，它必须实现 io.Reader 接口，这个接口只有一个签名是 Read(p []byte) (n int, err error) 的方法，它从调用它的对象上读取数据，并把读到的数据放入参数中的字节切片中，然后返回读取的字节数和一个 error 对象，如果没有错误发生返回 nil，如果已经到达输入的尾端，会返回 io.EOF(\"EOF\")，如果读取的过程中发生了错误，就会返回具体的错误信息。类似地，一个对象要是可写的，它必须实现 io.Writer 接口，这个接口也只有一个签名是 Write(p []byte) (n int, err error) 的方法，它将指定字节切片中的数据写入调用它的对象里，然后返回实际写入的字节数和一个 error 对象（如果没有错误发生就是 nil）。 io 包里的 Readers 和 Writers 都是不带缓冲的，bufio 包里提供了对应的带缓冲的操作，在读写 UTF-8 编码的文本文件时它们尤其有用。 ch28 进阶输入输出 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:8:2","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"空接口 空接口不包含任何办法，它对实现不做任何要求 type Any interface {} 任何其他类型都实现了空接口，any或Any是空接口一个很好的别名或缩写 可以给空接口类型的变量var val interface {} 赋予任何类型的值 空接口是一种接口，它是一种指针类型的数据类型，虽然不严谨，但它确实保存了两个指针，**一个是对象的类型(或iTable)，一个是对象的值。**所以赋值过程是让空接口any保存各个数据对象的类型和对象的值。 var test interface{} test = \"string\" ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:9:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"利用空接口构建通用类型的数组 让我们给空接口定义一个别名类型Element:type Element interface{} 然后定义一个容器类型的结构体Vector，它包含一个Element类型元素的切片 type Element interface{} type Vector struct { a []Element } func (p *Vector) At(i int) Element { return p.a[i] } func (p *Vector) Set(i int, e Element) { p.a[i] = e } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:9:1","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"复制数据切片至空接口切片 假设有一个myType类型的数据切片，若想将切片中的数据赋值到一个空接口切片中，类似 var dataSlice []myType = FuncReturnSlice() var interfaceSlice []interface{} = dataSlice 可惜不能这么做，编译时会出错： cannot use dataSlice (type []myType) as type []interface { } in assignment 原因是它们俩在内存中的布局是不一样的（参考 Go wiki）。 必须使用for-range语句来一个一个显示地赋值： var dataSlice []myType = FuncReturnSlice() var interfaceSlice []interface{} = make([]interface{}, len(dataSlice)) for i, d := range dataSlice { interfaceSlice[i] = d } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:9:2","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"通用类型的节点数据结构 package main import \"fmt\" type Node struct { le *Node data interface{} ri *Node } func NewNode(left, right *Node) *Node { return \u0026Node{left, nil, right} } func (n *Node) SetDate(data interface{}) { n.data = data } func main() { root := NewNode(nil, nil) root.SetData(\"root node\") a := NewNode(nil, nil) a.SetData(\"left node\") b := NewNode(nil, nil) b.SetData(\"right node\") root.le = a root.ri = b fmt.Printf(\"%v\\n\", root) } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:9:3","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"Go的动态类型 Go语言没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系 Go中的接口跟Java、C#类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口。 和其他语言相比，Go是唯一结合了接口值，静态类型检查（该类型是否实现了某个接口），运行时动态转换的语言，并且不需要显示地声明类型是否满足某个接口。 该特性允许我们在不改变已有代码地情况下定义和使用新接口。 类似于Python和Ruby这类动态语言中的动态类型duck typing 这意味这对象可以根据提供的方法被处理，而忽略它们的实际类型：它们能做什么比它们是什么更重要。 例1 package main import \"fmt\" type IDuck interface { Quack() Walk() } type Bird struct { // ... } func main() { b := new(Bird) DuckDance(b) } func (b *Bird) Quack() { fmt.Println(\"I am quacking!\") } func (b *Bird) Walk() { fmt.Println(\"I am walking!\") } func DuckDance(duck IDuck) { for i := 1; i \u003c= 3; i++ { duck.Quack() duck.Walk() } } 如果对 cat 调用函数 DuckDance()，Go 会提示编译错误，但是 Python 和 Ruby 会以运行时错误结束。 例2 pakcage main import \"fmt\" var ai AbsInterface var si SqrInterface var empty interface{} func main() { pp := new(Point) // 任意对象包括pp都实现了空接口，所以可以赋值给空接口empty empty = pp fmt.Printf(\"%T\\n\", empty) ai = empty.(AbsInterface) // ai = empty fmt.Printf(\"%T\\n\", ai) si = empty.(SqrInterface) fmt.Printf(\"%T\\n\", si) si = ai.(SqrInterface) fmt.Printf(\"%T\\n\", si) } type Point int type AbsInterface interface { Abs() float32 } type SqrInterface interface { Sqr() float32 } func (p *Point) Abs() float32 { return 10.0 } func (p *Point) Sqr() float32 { return 10.0 } 例3 package main import \"fmt\" func main() { mi := MyInt(5) var x Adder = \u0026mi x.add() // x.print() // x.print undefined (type Adder has no field or method print) x.(Printer).print() } type Printer interface { print() } type Adder interface { add() } type MyInt int func (i *MyInt) add() { fmt.Printf(\"%d\\n\", *i+1) } func (i *MyInt) print() { fmt.Printf(\"%v\\n\", *i) } x 转换为 Printer类型是完全动态的：只要 x 的底层类型（动态类型）定义了 print 方法这个调用就可以正常运行（译注：若 x 的底层类型未定义 print 方法，此处类型断言会导致 panic，最佳实践应该为 if mpi, ok := x.(myPrintInterface); ok { mpi.print() }）。 针对上述代码的个人理解：这里的话，如果一个对象实现了很多很多接口，然后将它赋值给一个接口变量，那么该对象实现的其他接口会暂时被隐藏起来。 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。对于动态语言非常重要的单元测试来说，这样既可以减少单元测试的部分需求，又可以发挥相当大的作用。 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:10:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"接口的提取 提取接口是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。 有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动（仅仅需要实现新接口的方法）。已有的函数可以扩展为使用接口类型的约束性参数：通常只有函数签名需要改变。对比基于类的 OO 类型的语言在这种情况下则需要适应整个类层次结构的变化。 因此，开发者不用提前设计出所有的接口；整个设计可以持续演进，而不用废弃之前的决定。类型要实现某个接口，它本身不用改变，只需要在这个类型上实现新的方法。 ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:11:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"接口的继承 ch18 自定义类型与结构体 当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。 例1 type Task struct { Command string *log.Logger } 这个类型的工厂方法像这样： func NewTask(command string, logger *log.Logger) *Task { return \u0026Task{command, logger} } 当 log.Logger 实现了 Log() 方法后，Task 的实例 task 就可以调用该方法： task.Log() 类型可以通过继承多个接口来提供像 多重继承 一样的特性： type ReaderWriter struct { *io.Reader *io.Writer } 例2 type intferface1 interface { read() } type intferface2 interface { write() } type myStruct1 struct { *myStruct2 } type myStruct2 struct { } func (t *myStruct1) read() { fmt.Println(\"reading\") } func (t *myStruct2) write() { fmt.Println((\"writing\")) } func main() { test := new(myStruct1) test.write() test.read() } ","date":"2022-03-04","objectID":"/2022/03/go-ch19/:12:0","tags":null,"title":"Ch19 接口","uri":"/2022/03/go-ch19/"},{"categories":["golang"],"content":"ch18 自定义类型与结构体 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:0:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"自定义类型 Go语言的关键字type可以将各种基本类型定义为自定义类型，而且每种自定义类型可以拥有自己的方法。 例如, package main import \"fmt\" type MyInt int32 func (m MyInt) Add(x MyInt) MyInt { return m + x } func main() { var x MyInt = 2 var y MyInt = 3 fmt.Println(x.Add(y)) } type 类型名 struct{} 可以理解为，将struct{}结构体定义为类型名的类型。结构体是一种复合的基本类型，通过type定义为自定义类型后，使结构体更便于使用。 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:1:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体定义 type identifier struct { field1 type1 field2 type2 ... } 结构体是复合类型、值类型 type T struct { a, b int}也合法 如果字段在代码中从来也不会用到，可以命名为_ 结构体的字段可以是任何类型，甚至是结构体本身，也可以是函数或接口 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:2:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"实例化、初始化 Point结构体定义为 type Point struct { X, Y int } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:3:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"基本形式 先声明，后初始化 var p Point p.X, p.Y = 10, 20 实例化时，使用结构体字面量进行初始化 p1 := Point{X:20, Y:15} p2 := \u0026Point{X:10, Y:20} 其中， \u0026Point{10, 20}是一种简写，底层仍然会调用new() 若不指定变量，则必须与定义顺序一致 type Interval struct { start int end int } intr := Interval{0, 3} (A) intr := Interval{end:5, start:1} (B) intr := Interval{end:5} (C) ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:3:1","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"new函数 point := new(Point) point.X, point.Y = 10, 20 这里，使用new获得的变量其实是*Point类型，但由于Go提供的语法糖，使得开发者访问结构体指针的成员变量时更加方便。该语法糖自动地将point.X转换为(*point).X 无论是一个结构体类型还是一个结构体类型指针，都可以使用name.fieldName来引用结构体字段 type myStruct struct { i int } var v myStruct // v是结构体类型变量 var p *myStruct // p是指向一个结构体类型变量的指针 v.i p.i ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:3:2","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体内存布局 Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。下面的例子清晰地说明了这些情况： type Rect1 struct {Min, Max Point} tyep Rect2 struct {Min, Max *Point} Go内存分配 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:4:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体工厂 Go语言不支持面向对象编程语言中的构造方法，但是在Go中可以为类型定义一个工厂，按惯例，以new或New开头，假设定义了如下File结构体类型 type Cat struct { Color string Name string } 下面是该结构体类型对应的工厂方法，返回一个指向结构体实例的指针 func NewCat(color, name string) *Cat { return \u0026Cat{color, name} } 调用方法 cat := NewCat(\"yellow\", \"mimi\") ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:5:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"方法 方法的声明和函数类似，方法是一种作用于特定类型变量的函数。这种特定类型变量叫做接收器（Receiver)。 接收器的概念类似于其他语言中的this或self 在Go语言中，接收器的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 注：不能是基础类型，也不能是接口。基础类型可以通过type自定义类型之后使用。 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:6:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"添加方法 格式如下： func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) { 函数体 } 接受器变量：命名时，官方建议使用接收器类型名的第一个小写字母 接收器类型：可以是指针类型和非指针类型 方法名、参数列表、返回参数：同函数 type person struct { name string } func (p person) String() string { return \"the person name is\" + p.name } 现在，类型person有了一个String方法，可通过如下方式进行调用 func main(){ p := person{name:\"张三\"} fmt.Println(p.String()) } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:6:1","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"接收器 接收器可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至是函数类型，可以是int、bool、string或数组的别名类型，但不能是一个接口类型 在Go中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，可以存放在不同的源文件中，但必须在同一个包中。也就是说，不能够给别的包中定义的类型追加方法，所以无法为int追加方法，但是可以为int重新命名后，追加方法。 别名类型没有原始类型上已经定义的方法 package main import \"fmt\" type MyInt int func (m MyInt) IsZero() bool { return m == 0 } func (m MyInt) Add(other MyInt) MyInt { return other + m } func main() { var a MyInt = 3 fmt.Println(a.IsZero()) fmt.Println(a.Add(MyInt(2))) } 类型T(或*T)上的所有方法的集合叫它的方法集(method set) 方法是函数，不允许方法重载。但具有同样名字的方法可以在2个或以上接收者类型上存在。 func (a *denseMatrix) Add(b Martix) Matrix func (a *denseMatrix) Add(b, c Matrix) Matrix //不允许 func (a *sparseMatrix) Add(b Matrix) Matrix //允许 指针类型与非指针类型接收器 在调用方法的时候，本质上都是值传递，只不过一个这个值副本，一个是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。 package main import \"fmt\" type person struct { name string } func main() { p := person{name:\"Tom\"} //p := person{name:\"Tom\"} p.modify() p.output() } func (p person) output() { fmt.Println(\"the person name is \" + p.name) } func (p *person) modify() { p.name = \"Tony\" } 自动取指针与自动解引用 在本节曾提到一个语法糖，这里stu.name其实应写为(*stu).name，记为自动解引用，下面介绍自动取指针。 package main type student { name string age int } func main() { stu := new(student) stu.name = \"Lily\" stu.age = 20 } 在指针类型与非指针类型接收器中的例子中，在调用接收器为指针类型的方法时，使用的是一个变量，并不是一个指针类型，其标准写法为， (\u0026p).modify() 如果没有强制使用指针进行调用，Go编译器会自动取指针，这是Go支持的一个语法糖。 同样的，如果是非指针类型接收器，使用指针类型调用，Go编译器会自动解引用。 (*p).String() 区别 当需要修改接收者中的值时或接收者拷贝代价比较大时用指针接收器 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:6:2","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"方法和函数的统一调用 无论时普通函数还是结构体的方法，只要签名一致，就都可以被赋值于同一签名的函数变量。 package main import \"fmt\" type class struct{ } func (c *class) Do(v int) { fmt.Printf(\"call method do: %d\\n\", v) } func funcDo(v int) { fmt.Printf(\"call function do: %d\\n\", v) } func execute(v int, entry func(int)) { entry(v) } func main() { c := new(class) execute(100, c.Do) execute(100, funcDo) } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:6:3","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"方法与未导出字段 firstName和lastName被设置为未导出字段，在包外无法访问，可通过导出的方法对其进行修改与访问。 package person type Person struct { firstName string lastName string } func (p *Person) FirstName() string { return p.firstName } func (p *Person) SetFirstName(newName string) { p.firstName = newName } package main import ( \"./person\" \"fmt\" ) func main() { p := new(person.Person) // p.firstName undefined // (cannot refer to unexported field or method firstName) // p.firstName = \"Eric\" p.SetFirstName(\"Eric\") fmt.Println(p.FirstName()) // Output: Eric } 对象的字段（属性）不应该由2个或2个以上的不同线程在同一时间去改变。如果在程序中发生这种情况，为了安全并发访问，可以使用包sync或者使用goroutines和channels ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:6:4","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"类型内嵌和结构体内嵌 结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为类型内嵌或匿名字段。 没有字段名的变量，在初始化和调用时直接使用类型，因此同种类型的匿名字段只能有一个。 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"类型内嵌 package main import \"fmt\" type student struct{ name string string int } func main(){ var stu1 student = student { name:\"haojie\", string:\"test\", int:6, } fmt.Println(stu1.string) } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:1","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体内嵌 普通的结构体嵌套如下， type address struct{ province string city string } type student struct{ name string add address } func main(){ stu1 := student{ name:\"haojie\", add:address{ province:\"河北\", city:\"xiongan\", } } } 但，结构体中的匿名字段可以是结构体，此时可以直接访问匿名结构体中的所有成员，这种方式被成为结构体内嵌 package main import \"fmt\" type address struct { province string city string } type people struct { name string address } func main() { // 内嵌结构体的初始化方式 p1 := people{ name: \"chao\", address: address{ \"zhejiang\", \"jiaxing\", }, } // 这样不行 // p2 := people { // name : \"hui\", // province : \"henan\", // city : \"luohe\", // } fmt.Println(p1.province) //fmt.Println(p2.province) } 在people中没有找到province变量，便去匿名结构体中寻找，但如果两个匿名结构体中都含有相同变量，则编译器无法识别会报错。 无论结构体有多少层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名。 内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名。 package main import \"fmt\" type contract struct { phone string wechat string qq string } type address struct { province string city string } type people struct { age int name string contract } type student struct { id int address people } func main() { stu := student { id : 1, address : address { province : \"zhejiang\", city : \"jiaxing\", }, people : people { age : 23, name : \"chao\", contract : contract { phone : \"159xxxx6132\", wechat : \"mcgt80611\", qq : \"864654710\", }, }, } fmt.Println(stu.qq) fmt.Println(stu.address.province) fmt.Println(stu.people.contract.phone) } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:2","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体内嵌模拟“继承” 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型继承了这些方法。 package main import \"fmt\" type animal struct { name string } func (a animal) move() { fmt.Printf(\"%s is moving\"\\n, a.name) } type dog struct { feetNum int animal } func (d dog) bark() { fmt.Printf(\"%s is barking\\n\", d.name) } func main() { d := dog{ feetNum: 4, animal: animal{ name: \"旺财\", }, } d.bark() d.move() } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:3","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"多重继承 多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++和Python例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在Go语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。 练习：假设有一个类型CameraPhone，通过它可以Call()，也可以TakeAPicture()，但是第一个方法属于类型Phone，第二个方法属于类型Camera，请编写相关代码。 package main import \"fmt\" type Phone struct { cpuKind string memorySize int } type Camera struct { foucs int depth float64 } type SmartPhone struct { prize float64 Phone Camera } func main() { sp := SmartPhone{3999.0, Phone{\"qilin\", 1024}, Camera{6, 123.7}} fmt.Println(sp) sp.Call() sp.TakeAPicture() } func (p *Phone) Call() { fmt.Println(\"calling\") } func (c *Camera) TakeAPicture() { fmt.Println(\"taking\") } 关于利用结构体与面向对象程序设计的相关问题，将在后续再系统地介绍。 Go面向对象 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:4","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"命名冲突 当两个字段拥有相同的名字（可能是继承来的名字）时该如何处理？ 外层名字会覆盖内层的名字，但是二者的内存空间都保留，这提供了一种重载字段或方法的方式 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误。没有办法来解决这种二义性，必须由程序员自己修正。 规则一 type A struct { a int } type B struct { a float32 A } func testStruct() { var b B b.a = 5.4 fmt.Println(b) b.A.a = 12 fmt.Println(b) } //{5.4 {0}} //{5.4 {12}} 规则二 type A struct { a int } type B struct { a, b int } type C struct { s1 A s2 B } type D struct { A B } func testStruct() { var c C c.s1.a = 5 c.s2.a = 3 fmt.Println(c) var d D d.a = 4 fmt.Println(d) } //{{5} {3 0}} //.\\main.go:54:3: ambiguous selector d.a ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:7:5","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"结构体标签 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:8:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"JSON序列化与反序列化 json JSON是一种轻量级的数据交换格式，JSON键值对是用来保存JS对象的一种方式。 // Student json type Student struct { ID int Gender string Name string } func main() { stu1 := Student{ ID: 1, Gender: \"male\", Name: \"chao\", } v, err := json.Marshal(stu1) if err != nil { fmt.Println(\"error\") } else { fmt.Println(v) fmt.Println(string(v)) fmt.Printf(\"%#v\\n\", string(v)) } str := \"{\\\"ID\\\":1,\\\"Gender\\\":\\\"male\\\",\\\"Name\\\":\\\"chao\\\"}\" stu2 := new(Student) json.Unmarshal([]byte(str), stu2) fmt.Println(stu2) } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:8:1","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"JSON标签 如何把序列化结果中的ID改成小写的？如果将结构体中的变量改成小写，json包将无法访问这些数据。 解决方法：使用结构体Tag 结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。 标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。 将在反射中深入的探讨 reflect包，它可以在运行时自省类型、属性和方法，比如：在一个变量上调用 reflect.TypeOf() 可以获取变量的正确类型，如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。 ch24 反射 // Student json type Student struct { ID int `json:\"id\"` Gender string `json:\"gender\"` Name string `json:\"name\"` } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:8:2","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"多个结构体标签的写法 如下所示，在````字符串内，使用空格符分隔 type Student struct { ID int `json:\"id\" gorm:\"primary_key` Gender string `json:\"gender\"` Name string `json:\"name\"` } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:8:3","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"类型的String()方法 使用String()方法来定制类型的字符串形式的输出，即一种可阅读性和打印性的输出。 如果类型定义了String()方法，它会被用在fmt.Printf()中生成默认的输出，等同于使用格式化描述符%v产生的输出。 在fmt.Print()和fmt.Println()中也会自动使用String()方法 package main import ( \"fmt\" \"strconv\" ) type TwoInts struct { a int b int } func main() { two1 := new(TwoInts) two1.a = 12 two1.b = 10 fmt.Printf(\"two1 is: %v\\n\", two1) fmt.Println(\"two1 is:\", two1) fmt.Printf(\"two1 is: %T\\n\", two1) fmt.Printf(\"two1 is: %#v\\n\", two1) } func (tn *TwoInts) String() string { return \"(\" + strconv.Itoa(tn.a) + \"/\" + strconv.Itoa(tn.b) + \")\" } //two1 is: (12/10) //two1 is: (12/10) //two1 is: *main.TwoInts //two1 is: \u0026main.TwoInts{a:12, b:10} 当广泛使用一个自定义类型时，最好为它定义 String()方法。从上面的例子也可以看到，格式化描述符 %T 会给出类型的完全规格，%#v 会给出实例的完整输出，包括它的字段（在程序自动生成 Go 代码时也很有用）。 例如：实现栈（stack）数据结构 package main import \"fmt\" import \"strconv\" const LIMIT = 20 type stackArr struct { arr [LIMIT]int top int } func newStackArr() *stackArr { return \u0026stackArr{arr: [LIMIT]int{}, top: -1} } type Stack struct { *stackArr } func NewStack() *Stack { return \u0026Stack{newStackArr()} } func (s *Stack) Pop() int { res := -1 if !s.Empty() { res = s.arr[s.top] s.arr[s.top] = 0 s.top-- } else { fmt.Println(\"error, the stack is empty\") } return res } func (s *Stack) Push(num int) { if !s.Full() { s.top++ s.arr[s.top] = num } else { fmt.Println(\"error, the stack is full\") } } func (s *Stack) Empty() bool { return s.top == -1 } func (s *Stack) Top() int { if !s.Empty() { return s.arr[s.top] } fmt.Println(\"error, the stack is empty, no top value\") return -1 } func (s *Stack) Full() bool { return s.top == LIMIT-1 } func (s *Stack) String() string { str := \"{\" for i, num := range s.arr { str += \"[\" + strconv.Itoa(i) + \":\" + strconv.Itoa(num) + \"]\" } str += \"}\" return str } func main() { s := NewStack() s.Push(5) s.Push(4) s.Push(68) fmt.Println(s) s.Pop() fmt.Println(s) s.Pop() s.Pop() s.Pop() s.Top() } ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:9:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"垃圾回收和SetFinalizer Go开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在Go运行时有一个独立的进程，即垃圾收集器（GC）会处理这些事情。 ch33 垃圾回收与变量逃逸分析 可以通过runtime包访问GC进程 runtime 通过调用runtime.GC()函数可以显式的触发GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用runtime.GC()，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为GC进程在执行） var m runtime.MemStats runtime.ReadMemStats(\u0026m) fmt.Printf(\"%d Kb\\n\", m.Alloc / 1024) 上述程序会给出已分配内存的总量，单位是Kb 如果需要在一个对象obj被从内存移除前执行一些特殊操作，比如写到日志文件里，可以通过如下方式调用函数来实现 runtime.SetFinalizer(obj, func(obj *typeObj)) func(obj *typeObj) 需要一个 typeObj 类型的指针参数 obj，特殊操作会在它上面执行。func 也可以是一个匿名函数。 在对象被 GC 进程选中并从内存中移除以前，SetFinalizer 都不会执行，即使程序正常结束或者发生错误。 https://studygolang.com/pkgdoc 终止器会在obj变为不可接触之后的任意时间被调度执行。不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个os.File对象时没有调用其Close方法，该os.File对象可以使用终止器去关闭对应的操作系统文件描述符。但依靠终止器去刷新内存中的I/O缓冲如bufio.Writer是错误的，因为缓冲不会在程序退出时被刷新。 ","date":"2022-02-20","objectID":"/2022/02/go-ch18/:10:0","tags":null,"title":"Ch18 自定义类型与结构体","uri":"/2022/02/go-ch18/"},{"categories":["golang"],"content":"ch17 error,panic与recover ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:0:0","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"运行时错误 Go语言的错误处理思想及设计包含以下特征 一个可能造成错误的函数，需要返回值中返回一个错误接口（error）。如果调用是成功的，错误接口将返回nil，否则返回错误。 在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。 Go没有类似Java或.Net中的异常处理机制，虽然可以使用defer、recover、panic进行模拟，但官方并不推荐。Go的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的错误付出太多的资源。Go语言希望开发者将错误处理是为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。 ch34 错误处理机制 ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:1:0","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"error接口 type error interface { Error() string } 所有符合Error() string格式的方法，都能实现错误接口，该方法返回错误的具体描述。 ch18 自定义类型与结构体 ch19 接口 ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:1:1","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"自定义错误 方法一: 使用errors包进行错误的定义，格式如下 var err = errors.New(\"this is an error\") 错误字符串由于相对固定，故一般在包作用域声明，应尽量减少在使用时直接使用errors.New()返回 package main import ( \"errors\" \"fmt\" ) var errDivisionByZero = errors.New(\"division by zero\") func Div(dividend, divisor float64) (float64, error) { if divisor == 0 { return math.NaN(), errDivisionByZero } return dividend/divisor, nil } func main() { res, nil := test.Div(20, 0) fmt.Println(res, nil) } 拓展 errors.New()的底层代码 func New(text string) error { return \u0026errorString(text) } // errorString实现了error接口 func (e *errorString) Error() string { return e.s } func errorString struct { s string } 方法二: 自定义结构体，记录一些文件名，行数等信息，使得error信息更加丰富 package main import ( \"math\" \"fmt\" \"runtime\" ) type DivError struct{ FileName string Line int } func (d *DivError) Error() string { return fmt.Sprintf(\"%s:%d division by zero\", d.FileName, d.Line) } func newDivError(filename string, line int) error { return \u0026DivError{FileName:filename, Line:line} } func Div(dividend, divisor float64) (float64, error) { if divisor == 0 { _, filename, line, _ := runtime.Caller(1) return math.NaN(), newDivError(filename, line) } return dividend/divisor, nil } func main() { res, nil := Div(20, 0) fmt.Println(res, nil) } func Caller(skip int) (pc uintptr, file string, line int, ok bool) Caller报告当前go协程调用栈所执行的函数的文件和行号信息。实参skip为上溯的栈帧数，0表示Caller的调用者（Caller所在的调用栈）。（由于历史原因，skip的意思在Caller和Callers中并不相同。）函数的返回值为调用栈标识符、文件名、该调用在文件中的行号。如果无法获得信息，ok会被设为false。 ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:1:2","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"error与类型断言 类型断言将在接口中详细说明，在此只需记住 var.(type) 可以获取变量的类型 如果一个函数返回多个error，例如如下代码，可用类型断言判断类型 package main import ( \"math\" \"fmt\" \"runtime\" ) type InputError struct { FileName string Line int Num float64 } func (i *InputError) Error() string { return fmt.Sprintf(\"%s:%d %.2g input error\", i.FileName, i.Line, i.Num) } func newInputError(filename string, line int, num float64) *InputError { return \u0026InputError{FileName:filename, Line:line, Num:num} } type DivError struct{ FileName string Line int } func (d *DivError) Error() string { return fmt.Sprintf(\"%s:%d division by zero\", d.FileName, d.Line) } func newDivError(filename string, line int) error { return \u0026DivError{FileName:filename, Line:line} } func Div(dividend, divisor float64) (float64, error) { if dividend \u003c 0 { _, filename, line, _ := runtime.Caller(1) return math.NaN(), newInputError(filename, line, dividend) } else if divisor \u003c 0 { _, filename, line, _ := runtime.Caller(1) return math.NaN(), newInputError(filename, line, divisor) } if divisor == 0 { _, filename, line, _ := runtime.Caller(1) return math.NaN(), newDivError(filename, line) } return dividend/divisor, nil } func main() { res, err := Div(20, 0) switch detail := err.(type) { case *InputError: fmt.Printf(\"%s:%d %.2g, input doesn't fit\\n\", detail.FileName, detail.Line, detail.Num) case *DivError: fmt.Printf(\"%s:%d division is zero\\n\", detail.FileName, detail.Line) default: fmt.Println(\"other error\") } fmt.Println(res) } https://blog.csdn.net/shida_csdn/article/details/88057989 https://stackoverflow.com/questions/23172219/cannot-type-switch-on-non-interface-value ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:1:3","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"panic Go语言可以在程序中手动触发宕机，让程序崩溃，以便开发者及时发现错误。 panic的参数可以是任意类型，后文提到的recover会接收从panic中发出的内容。 package main func main() { panic(\"crash\") } ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:2:0","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"主动触发panic regexp是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的。 1. func Compile(exptr string) (*Regexp, error) 2. func MustCompile(str string) *Regexp 第一个函数适用于在编译错误时获得编译错误并进行处理，同时继续后续执行的环境。 第二个函数适用于无需处理正则表达式错误的情况，其代码为 func MustCompile(str string) *Regexp { regexp, error := Complie(str) if error != nil { panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) } return regexp } 手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生。 不过，如果任何错误都用宕机处理，也不是良好的设计，因此应根据需要来决定是否使用当即进行报错。 ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:2:1","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"延迟语句 当panic发生时，panic后面的代码不会被执行，但是在panic前的defer语句会在宕机前发生作用。 利用该特性，可以用来在宕机发生前进行一些必要的处理。 package main import \"fmt\" func main() { defer fmt.Println(\"test1\") defer fmt.Println(\"test2\") panic(\"crash\") } test2 test1 panic: crash goroutine 1 [running]: main.main() E:/workspace_go/main.go:8 +0xe5 ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:2:2","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"recover 无论是由runtime层抛出的panic，还是在代码中主动触发的panic，都可以配合defer和recover实现错误的捕捉和恢复，让代码在发生崩溃后允许继续运行。 package main import ( \"fmt\" ) func main() { fmt.Println(\"Start.....\") defer func() { err := recover() if err != nil { fmt.Println(\"recover\") } }() panic(\"crash\") // unreachable code fmt.Println(\"End.....\") } 当panic触发崩溃时，main函数将结束运行，此时defer后的闭包将会发生调用，调用结束后，整个程序结束。 下面的代码实现了一个ProtectRun()函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生Panic崩溃后，可以将崩溃的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。 package main import ( \"fmt\" \"runtime\" ) func ProtectRun(entry func()) { defer func() { err := recover() if err != nil { switch err.(type) { case runtime.Error: fmt.Println(\"runtime error: \", err) default: fmt.Println(\"error: \", err) } } }() entry() } func main() { fmt.Println(\"Start.....\") ProtectRun(func() { fmt.Println(\"before crash\") panic(\"crash\") fmt.Println(\"after crash\") }) ProtectRun(func() { fmt.Println(\"before crash\") // runtime error var a *int *a = 1 fmt.Println(\"after crash\") }) fmt.Println(\"End.....\") } Start..... before crash error: crash before crash runtime error: runtime error: invalid memory address or nil pointer dereference End..... ","date":"2022-02-15","objectID":"/2022/02/go-ch17/:3:0","tags":null,"title":"Ch17 匿名函数与闭包","uri":"/2022/02/go-ch17/"},{"categories":["golang"],"content":"ch16 defer ","date":"2022-01-28","objectID":"/2022/01/go-ch16/:0:0","tags":null,"title":"Ch16 defer","uri":"/2022/01/go-ch16/"},{"categories":["golang"],"content":"defer的概念 Go语言中defer语句会将其后面跟随的语句进行延迟处理，当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，**defer后的函数才会被执行，**不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。 可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。 注意下述代码中输出的num的值，紧跟着defer后的语句输出的num值为10，而不是30 package main import \"fmt\" func main(){ defer fmt.Println(\"1\") defer fmt.Println(\"2\") defer fmt.Println(\"3\") outputNum() } func outputNum() bool { num := 10 defer fmt.Printf(\"%d with defer\\n\", num) num += 20 fmt.Printf((\"%d without defer\\n\", num) return true } // 30 without defer // 10 with defer // 3 // 2 // 1 ","date":"2022-01-28","objectID":"/2022/01/go-ch16/:1:0","tags":null,"title":"Ch16 defer","uri":"/2022/01/go-ch16/"},{"categories":["golang"],"content":"defer的用途 defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。 package main import \"fmt\" func main() { doDBOperations() } func connectToDB() { fmt.Println(\"ok, connected to db\") } func disconnectFromDB() { fmt.Println(\"ok, disconnected from db\") } func doDBOperations() bool { connectToDB() fmt.Println(\"Defering the database disconnect.\") defer disconnectFromDB() //function called here with defer fmt.Println(\"Doing some DB operations ...\") fmt.Println(\"Oops! some crash or network error ...\") fmt.Println(\"Returning from function here!\") return false //terminate the program // deferred function executed here just before actually returning, even if // there is a return or abnormal termination before } 使用defer并发解锁 在下面的例子中会在函数中并发使用map，为防止竞态问题，使用sync.Mutex进行加锁，参见下面的代码 var ( valueByKey = make(map[string]int) valueByKeyGuard sync.Mutex ) func readValue(key string) int { valueByKeyGuard.Lock() v := valueByKey[key] valueByKeyGuard.UnLock() return v } map并不是并发安全的，所以使用sync.Mutex互斥量保护map的访问，可以使用defer对上述语句进行简化 map和slice并不是并发安全的，具体的参考 ch25 并发编程 func readValue(key string) int { valueByKeyGuard.Lock() defer valueByKeyGuard.Unlock() return valueByKey[key] } 使用defer释放文件句柄 文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源。 func fileSize(filename string) int64 { f, err := os.Open(filename) if err != nil { return 0 } info, err := f.Stat() if err != nil { f.Close() return 0 } size := info.Size() f.Close() return size } 使用defer简化后， func fileSize(filename string) int64 { f, err := os.Open(filename) if err != nil { return 0 } defer f.Close() if info, err := f.Stat(); err == nil { return info.Size() } return 0 } ","date":"2022-01-28","objectID":"/2022/01/go-ch16/:2:0","tags":null,"title":"Ch16 defer","uri":"/2022/01/go-ch16/"},{"categories":["golang"],"content":"Defer a function call (with return value) https://yourbasic.org/golang/defer/ func foo() (result string) { defer func() { result = \"Change World\" // change value at the very last moment }() return \"Hello World\" } package main import \"fmt\" func foo() (result int) { defer func() { result = 4 }() result = 2 * 3 return 1 } func main() { res := foo() fmt.Println(res) //4 } 带命名返回值的函数，使用 return 1这种方式返回时，其实进行了两步操作，即return 1等价于 res = 1 return res 所以defer语句，在函数返回之前，又对res进行了修改，所以最终的结果是4 ","date":"2022-01-28","objectID":"/2022/01/go-ch16/:3:0","tags":null,"title":"Ch16 defer","uri":"/2022/01/go-ch16/"},{"categories":["golang"],"content":"ch15 匿名函数与闭包 ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:0:0","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"第一类值 在Go语言中，函数被看作第一类值(first-class values)：①函数拥有类型，可以②被赋值给其他变量，③作为参数传递给函数，④作为参数被返回。 第一类值（一等公民）概念出自函数式编程，在此不做介绍 // 函数的类型 package main import \"fmt\" func main() { fmt.Printf(\"%T\\n\", addInt) fmt.Printf(\"%T\\n\", addFloat64) } func addInt(x, y int) int { return x + y } func addFloat64(x, y float64) float64 { return x + y } // func(int, int) int // func(float64, float64) float64 package main import \"fmt\" func main() { // 作为返回值，赋值给其他变量 op1 := selector('+') op2 := selector('-') // 作为参数 calculator(20, 30, op1) calculator(20, 30, op2) } func add(a, b int) int { return a + b } func sub(a, b int) int { return a - b } func selector(op byte) func(int, int) int { switch op { case '+': return add case '-': return sub default: return nil } } func calculator(x, y int, f func(int, int) int) { res := f(x, y) fmt.Println(res) } ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:1:0","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"匿名函数 匿名函数与之前提到的函数区别在于没有函数名，只有函数体。 例如， func (x, y int) int { return x + y } 匿名函数不能单独存在，一般有如下的使用方式 func main() { //1.加上括号，直接调用 fun () { fmt.Println(\"hi\") }() //2.赋值给变量、作为参数或返回值等 //2.1函数字面量复制给变量 //:=之后是一个寻找`nums`数组中第一个大于等于`target`的函数字面量 //将其赋值给`binarySearchFirst`，编译器会自动推导`binarySearchFirst`的类型。 binarySearchFirst := func(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := (low + high) / 2 if nums[mid] \u003e= target { high = mid - 1 } else { low = mid + 1 } } return low } } 一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数时非常有用。书写一个工厂函数而不是针对每种情况都书写一个函数。 此代码涉及了闭包的概念，见下一小节 //2.2作为返回值 func MakeAddSuffix(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } func main() { addBmp := MakeAddSuffix(\".bmp\") addJpeg := MakeAddSuffix(\".jpeg\") addBmp(\"file\") //file.bmp addJpeg(\"file\") //file.jpeg } //2.3作为参数 package main import \"fmt\" func main() { calculate(20, 30, func(a, b int) { fmt.Println(a + b) }) } func calculate(x, y int, f func(int, int)) { f(x, y) } 观察可得，匿名函数与函数的用途非常相似，如何将二者联系起来？ 在ch6常量与变量中曾提及有名常量和无名常量，无名常量例如2，有名常量即通过const 定义的有名常量const num int = 2。因此，使用如下形式声明函数时，可以理解为一个匿名函数绑定一个唯一的名字。这个过程就类似于声明一个有名常量，为无名常量2绑定一个名称，之后就可以使用名称来代指2。 这里的描述为个人理解，具体还有待商榷，对结构体中的方法是否适用？要验证其正确性，需要去了解函数与结构体中的方法底层实现的差别。未完待续 常量有时称为字面量（literal），基于二者的相似性，匿名函数也可被称为函数字面量 func functionName(param1 type1, param2 type2) (type3) { ... return res } ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:2:0","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"闭包 拥有函数名的函数只能在包级声明，不能在函数内部声明，但可以引入函数字面量（匿名函数）来解决此需求。 例如，在函数中想要对一棵树进行遍历，但又不想在函数外另外再声明一个函数，可以使用匿名函数的方式，将匿名函数赋值给traverse，之后便可以向正常调用函数一样，使用traverse函数。 leetcode 563 求解一棵二叉树的坡度 一棵树的坡度定义为，所有节点的坡度之和。 树中一个节点Node的坡度定义为，Sum(Node.Left)与Sum(Node.Right)差的绝对值。 Sum函数是以该节点为根的树中所有节点的值之和。 在函数内部引入了匿名函数辅助解决一些模块化的问题时，免不了需要进行数据的交互，例如在上述问题中需要考虑如何记录各个节点的坡度之和。问题的难点在于traverse函数如何在递归遍历的过程中，将计算得到的各节点坡度信息传递给FindTilt函数。 使用C++解决的方法可以是，①设置一个成员变量（或者全局变量），令dfs函数在递归遍历的过程中修改ans值，②修改dfs函数的定义，额外传入一个int类型的引用，用于记录结果。 C++解决办法 // 成员变量 class Solution { public: int ans = 0; int findTilt(TreeNode* root) { dfs(root, ans); return ans; } int dfs(TreeNode* node, \u0026int ans) { if (node == nullptr) { return 0; } int sumLeft = dfs(node-\u003eleft); int sumRight = dfs(node-\u003eright); ans += abs(sumLeft - sumRight); return sumLeft + sumRight + node-\u003eval; } }; class Solution { public: int findTilt(TreeNode* root) { int ans = 0; dfs(root, ans); return ans; } int dfs(TreeNode* node, int\u0026 ans) { if (node == nullptr) { return 0; } int sumLeft = dfs(node-\u003eleft, ans); int sumRight = dfs(node-\u003eright, ans); ans += abs(sumLeft - sumRight); return sumLeft + sumRight + node-\u003eval; } }; Go通过增加返回值，或者使用指针 在leetcode563v1中令遍历函数traverse每次都返回两个值，sum和lValue+rValue+root.Val分别用于自底向上遍历树时，对坡度与节点值之和进行累记。 // leetcode563v1 func FindTilt(root *utils.TreeNode) int { var traverse func(root *utils.TreeNode) (int, int) traverse = func(root *utils.TreeNode) (int, int) { sum := 0 if root == nil { return 0, 0 } sumL, lValue := traverse(root.Left) sumR, rValue := traverse(root.Right) sum = abs(rValue - lValue) + sumL + sumR return sum, lValue + rValue + root.Val } res, _ := traverse(root) return res } 此外，也可以使用传入int指针的方式解决。 // leetcode563v2 func FindTilt(root *utils.TreeNode) int { var traverse func(root *utils.TreeNode, sum *int) int sum := 0 traverse = func(root *utils.TreeNode, sum *int) int { if root == nil { return 0 } lValue := traverse(root.Left, sum) rValue := traverse(root.Right, sum) (*sum) += abs_int(rValue - lValue) return lValue + rValue + root.Val } traverse(root, \u0026sum) return sum } Go语言提供了一个非常优秀的特性，匿名函数可以捕获外部环境中的自由变量，并且具有记忆效应。 一个匿名函数与外部环境相组合，便形成了闭包（Closure）。简单地，闭包可以理解为一个引用了外部变量的匿名函数。 闭包应该也是一个函数式编程中的概念，在此不做过多解释 ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:3:0","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"捕获外部变量 可以注意到Accumulator函数返回的是一个类型为func() int的函数值， 所以使用return返回一个类型符合的匿名函数。但startValue声明的位置在匿名函数外，而匿名函数中的逻辑却尝试对startValue进行了修改， 并且能够成功编译运行。 package main import \"fmt\" func Accumulator() func() int { startValue := 1 fmt.Printf(\"The address of startValue is %x\\n\", \u0026startValue) return func() int { fmt.Printf(\"In annoymous function, address is %x\\n\", \u0026startValue) startValue++ return startValue } } func main() { accumulator := Accumulator() fmt.Println(accumulator()) accumulator() accumulator() accumulator() fmt.Println(accumulator()) newAccumulator := Accumulator() fmt.Println(newAccumulator()) } 该代码能够成功运行的原因在于匿名函数可以捕获了外部环境中变量的特性。捕获之后，便可以将其视为一般的变量进行操作与修改，并且所有的修改操作均会反应在外部环境中。 比如，匿名函数捕获了sum变量，然后将匿名函数本身的函数值赋值给traverse。在递归遍历的过程中，不断对sum进行修改，但在匿名函数外访问sum时，值不再是原来的0。 // leetcode563v3 func FindTilt(root *utils.TreeNode) int { var traverse func(root *utils.TreeNode) int sum := 0 traverse = func(root *utils.TreeNode) int { if root == nil { return 0 } lValue := traverse(root.Left) rValue := traverse(root.Right) sum += abs(rValue - lValue) return lValue + rValue + root.Val } traverse(root) return sum } ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:3:1","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"记忆效应 被引用的自由变量和匿名函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。 被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命周期一直存在，闭包本身就如同变量一样拥有了记忆效应。 package main import \"fmt\" func generator() func() int { value := 0 return func() int { value++ fmt.Println(value) return value } } func main() { f := generator() f() f() f() f = generator() f() } //1 //2 //3 //1 这里generator函数返回的是函数f捕获了value变量，并且f在main函数中执行，已经离开了原来的环境，但是还能正常运行，且随着f的生命周期一直存在。 ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:3:2","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"记忆效应的 底层原理 变量逃逸分析 https://blog.csdn.net/weixin_42117918/article/details/90409744 简而言之，Go编译器检测到局部变量仍有指针指向访问，原本应该分配在栈内的局部变量放在堆中，这种情况称之为变量逃逸。 ch33 垃圾回收与变量逃逸分析 go run -gcflags \"-m -l\" main.go 使用 go run 运行程序时，-gcflags 参数是编译参数。其中 -m 表示进行内存分配分析，-l表示避免程序内联，也就是避免进行程序优化。 package main import \"fmt\" func Accumulator() func() int { startValue := 1 fmt.Printf(\"The address of startValue is %x\\n\", \u0026startValue) return func() int { fmt.Printf(\"In annoymous function, address is %x\\n\", \u0026startValue) startValue++ return startValue } } func main() { accumulator := Accumulator() fmt.Println(accumulator()) accumulator() accumulator() accumulator() fmt.Println(accumulator()) newAccumulator := Accumulator() fmt.Println(newAccumulator()) } go run -gcflags \"-m -l\" main.go # command-line-arguments .\\main.go:6:2: moved to heap: startValue .\\main.go:7:12: ... argument does not escape .\\main.go:8:9: func literal escapes to heap .\\main.go:9:13: ... argument does not escape .\\main.go:17:13: ... argument does not escape .\\main.go:17:25: accumulator() escapes to heap .\\main.go:21:13: ... argument does not escape .\\main.go:21:25: accumulator() escapes to heap .\\main.go:24:13: ... argument does not escape .\\main.go:24:28: newAccumulator() escapes to heap The address of startValue is c0000aa058 In annoymous function, address is c0000aa058 2 In annoymous function, address is c0000aa058 In annoymous function, address is c0000aa058 In annoymous function, address is c0000aa058 In annoymous function, address is c0000aa058 6 The address of startValue is c0000aa088 In annoymous function, address is c0000aa088 2 ","date":"2022-01-24","objectID":"/2022/01/go-ch15/:3:3","tags":null,"title":"Ch15 匿名函数与闭包","uri":"/2022/01/go-ch15/"},{"categories":["golang"],"content":"ch14 包与变量作用域 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:0:0","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"作用域 在正式引入匿名函数与闭包之前，需要了解变量的作用域与生命周期两个概念。 这是两个完全不同的概念， 作用域：源代码中可以有效使用这个名字的范围，是一个编译时的属性。 生命周期：程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用，是一个运行时的概念。 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:1:0","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"作用域级别 语句块内部声明的变量在外部是无法被访问的，此语句块即内部所声明变量的作用域。 语句块：由花括弧所包含的一系列语句，例如函数体或循环体包裹的一系列语句。 变量的作用域可分为以下四个级别 元作用域：在函数内部由switch、if、for等引入的作用域 在switch、for、if后的初始化条件中声明的变量，其作用域范围为整个switch、if、for语句块 对于for和if，每个语句块，即花括号包裹的部分，代表一个更小的作用域；对于switch，每个分支代表一个更小的作用域。 函数作用域：在函数，如main函数中声明的变量，其作用域为整个函数体 包作用域：任何在函数外声明的变量可在同一个包的任何源文件中进行访问，其作用域为整个包。 全作用域：特别地，当在函数外声明的变量首字母大写时，该变量可通过packageName.VarName的方式在包外进行访问。 变量或者函数以大写字母开头时，此时称该变量或函数是在包外可见的或可导出的，即它们可在包外被访问，具体内容参考下文中的包。 一个程序可能包含多个同名变量，但只要属于不同的作用域就不会产生冲突，例如 循环内声明一个的局部变量（元作用域）可以和包级的变量（包作用域）同名 在两个不同的循环内，各声明一个名为x的变量，此时也不会产生冲突，x(循环A中)与x'(循环B中)在各自的元作用域内有效 对于全作用域，如果在包pkg1和pkg2中各有一个名为StuNum的可导出变量（具体内容参考包），此时也不会发生冲突，因为在使用时必须加上包名，即pkg1.StuNum，pkg2.StuNum 编译器解析变量时，会查找该变量的定义，从当前所在的作用域出发，最内部作用域中的声明会被首先找到，此时就屏蔽了外部作用域的同名声明。 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:1:1","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"具体实例 含如此多同名变量，是非常糟糕的编程习惯，在平时应避免这种情况的发生。 test1.go package test import \"fmt\" var Num int = 20 var x int = 30 func TestScope1() { fmt.Println(\"the x in main package is \", x) x := 10 fmt.Println(\"the x in function is \", x) // from now on, x refers to the x declared in the function for x := 0; x \u003c 5; x++ { // in this loop x refers to the variation declared last line fmt.Println(\"the x in loop is \", x) } fmt.Println(\"the x in function is still\", x) if x := 2*x; x \u003e 10 { // declare varation tmp just for testing wheather can input tmp in else block or not tmp := x; fmt.Println(\"the x in if block is\", x) fmt.Println(tmp, \" plus 5 is\", tmp+5) } else { fmt.Println(\"try to get the value of tmp\") // fmt.Println(tmp) // .\\main.go:26:15: undefined: tmp } } func print6X() { fmt.Println(\"use printX output x * 6 is\", x*6) } test2.go package test import \"fmt\" func TestScope2() { print6X() fmt.Println(\"output x in TestScope2, x is \", x) } main.go package main import ( \"fmt\" \"programs/test\" ) func main() { fmt.Println(\"Num in pkg test is \", test.Num) test.TestScope1() test.TestScope2() } Num in pkg test is 20 the x in main package is 30 the x in function is 10 the x in loop is 0 the x in loop is 1 the x in loop is 2 the x in loop is 3 the x in loop is 4 the x in function is still 10 the x in if block is 20 20 plus 5 is 25 use printX output x * 6 is 180 output x in TestScope2, x is 30 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:1:2","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"包(package) Go语言中的包和其他语言中的库，包等概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。 一个包由位于同名目录下的一个或多个.go源代码文件组成。 每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。 包可以控制变量或函数等在包外是否可见来隐藏内部实现信息 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:2:0","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"可见性 变量或者函数以大写字母开头时，此时称该变量或函数是在包外可见的或可导出的，即它们可在包外被访问。 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:2:1","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"导入包 在Go语言程序中，每个包都有一个全局唯一的导入路径。 按照惯例，将导入路径的最后一个字段作为包名 使用GOPATH模式时，编译器会依据$GOROOT/src/importpath依次来寻找包，此外，不建议使用相对路径来导入包。 使用GoModule时，假设在根目录下使用go mod init minidb进行了初始化，则导入此根目录下的包路径为minidb/packageName 单行导入 import \"path1/pkg1\" import \"path2/pkg2\" 多行导入 import ( \"path1/pkg1\" \"path2/pkg2\" ) 导入后自定义引用的包名 import customName \"path/to/package\" 指定新的包名，来避免导入重名包。 import ( \"crypto/rand\" mrand \"math/rand\" // alternative name mrand avoids conflict ) 匿名导入包 只导入包，让其执行init函数，而不使用任何包内的结构和类型，也不调用包内的任何函数 import _ \"path/to/package\" ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:2:2","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"包的初始化 在某些情况下，在调用已经封装好的模块时，往往需要人为地执行一个初始化函数，例如在初学数据结构时，会经常遇到StackInit，QueueInit，GraphInit等函数。这些函数需要开发者自己手动调用，那么这个过程可能发生遗漏或者错误。 由此，迫切地希望被引用的包，能够获得启动代码的通知，在程序启动时做一些自行执行一些初始化工作。基于此，Go语言中设置了init函数来完成此项功能。 每个.go文件都可包含一个init函数 init函数会在程序执行前(main函数执行前)被自动调用 调用顺序与包中变量的初始化顺序如下图所示 同一个包中的多个init函数调用顺序不可预期 init函数不能被其他函数调用 ","date":"2022-01-22","objectID":"/2022/01/go-ch14/:2:3","tags":null,"title":"Ch14 包与变量作用域","uri":"/2022/01/go-ch14/"},{"categories":["golang"],"content":"ch13 函数 Go语言中的函数没有默认参数。 Go不支持函数重载特性，主要原因是函数重载需要进行多余的类型匹配影响性能。 Go从1.18开始支持泛型，具体地参见 ch32 泛型 从广义上说，Go语言中有三种类型的函数，分别是普通的带有名字的函数、匿名函数或lambda函数、与结构体相关的方法。 可以把方法类比为C++中的成员函数。 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:0:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"命名规范 返回某个对象的函数或者方法，一般都是用名词，不用Get...。如果用于修改某个对象，则使用SetName。一般使用驼峰命名法，不用下划线分割多个名称。 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:1:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"函数声明 // 代码1、非命名返回值 func functionName1(param type) type { ... return ret } // 代码2、命名返回值 func functionName2(param1, param2 type) (ret type) { ... return } // 3、多值返回，可变参数 func functionName3(params ...type) (int, error) { ... return cnt, nil } ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:2:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"支持多值返回 Go语言支持函数多值返回，也就是说定义的函数可以返回多个值，常见的有返回error类型，以供判断是否执行成功。 func main(){ file, err :=os.Open(\"/usr/tmp\") if err != nil{ log.Fatal(err) return } fmt.Println(file) } ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:2:1","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"命名返回值和非命名返回值 在声明函数时，若未明确返回值名称，则称之位为未命名返回值，如上述代码1；相对应地在声明时，明确了返回值名称，则称之为命名返回值，如上述代码2。 package main import ( \"fmt\" ) var num1 int = 10 var num2, num3 int func main() { num2, num3 = resultWithDefinedRet(num1) fmt.Println(num2, num3) num2, num3 = resultWithUndefinedRet(num1) fmt.Println(num2, num3) } func resultWithDefinedRet(num int) (x, y int) { x, y = num*2, num*3 return } func resultWithUndefinedRet(num int) (int, int) { return num*2, num*3 } 尽量使用命名返回值，会使代码更清晰、更简短，同时更加容易读懂 两种方式看似简单没有什么区别，但当defer和return结合时，就会出现很多问题，具体内容将在引入defer介绍。 ch16 defer ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:2:2","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"支持可变参数 可变参数的定义，在类型前面加上省略号...即可 package main import ( \"fmt\" ) func main() { res1 := sum(1, 2, 3) res2 := sum(7, 9, 1) fmt.Println(res1, res2) } func sum(arr ...int) (ret int) { for _, num := range arr { ret += num } return } 固定参数和可变参数同时出现，可变参数放在最后 可变参数本质上是一个数组，所以可以像使用数组一样使用它，比如例子中的for range循环。 可通过...将slice中的数据转变为函数中需要的可变参数 package main import ( \"fmt\" ) func main() { strs := []string{\"hi, \", \"Joe.\", \"hi, \", \"Anna.\"} output1(strs...) output2(strs) } func output1(strs ...string) { for _, str := range strs { fmt.Print(str) } fmt.Printf(\"\\noutput1:%T\\n\", strs) } func output2(strs []string) { for _, str := range strs { fmt.Print(str) } fmt.Printf(\"\\noutput2:%T\\n\", strs) } // hi, Joe.hi, Anna. // output1:[]string // hi, Joe.hi, Anna. // output2:[]string 如果变长参数的类型没有指定，可以使用空接口interface{},结合反射与switch结构确定参数的类型 ch19 接口 ch24 反射 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:2:3","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"特殊函数 一个保重除了main()、init()函数外，其他所有类型的函数都可以有参数和返回值。 init 函数，一个包的初始化函数，在引入一个包后，最先执行的就是init函数，被不同源文件多次引入时，也只会执行一次。 main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init函数则会先执行该函数）。 main 函数既没有参数，也没有返回类型。 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:3:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"内置函数 close函数：主要用来关闭channel len函数：len用于返回某个类型的长度或数量（字符串、数组、切片、map和管道） cap函数：cap是容量的意思，用于返回某个类型的最大容量（只能用于切片和map) new，分配内存，分配值类型，比如int, struct，返回的是指针 make，分配内存，主要用来分配引用类型，比如chan,map,slice pannic和recover，用来做错误处理 copy、append：用于复制和连接切片 print、println：底层打印函数，在部署环境中建议使用fmt包 complex、real、imag：用于创建和操作复数 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:4:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"注意事项 函数值之间不能相互比较（nil例外） 函数不能在其它函数里面声明（不能嵌套），不过可以通过使用匿名函数来破除这个限制 可以返回其他函数的函数和接收其他函数作为参数的函数均被称为高阶函数，这是函数式语言的特点。显然，Go语言具有一些函数式语言的特性。 目前 Go 没有泛型（generic）的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口（interface），特别是空接口与类型选择与或者通过使用反射来实现相似的功能。使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，最好是为每一个类型单独创建一个函数，而且代码可读性更强。 Go从1.18开始支持泛型，具体参见 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:5:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"匿名函数 ch15 匿名函数与闭包 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:6:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"方法 ch18 自定义类型与结构体 ","date":"2022-01-20","objectID":"/2022/01/go-ch13/:7:0","tags":null,"title":"Ch13 函数","uri":"/2022/01/go-ch13/"},{"categories":["golang"],"content":"ch12 切片 切片是一种数据结构，围绕动态数组的概念设计的，可以按需自动改变大小，使用这种结构，可以更方便地管理和使用数据集合。 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:0:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"内部实现 切片是对数组一个连续片段的引用，该数组称之为相关数组，通常都是匿名的，所以说切片是一个引用类型。由于底层的内存是连续分配的，所以效率非常高。此外，切片还拥有可以通过索引获得数据，可以迭代以及垃圾回收的好处。 切片对象非常小，是一个只有三字段的数据结构，包括指针，切片长度，切片容量。 type slice struct { array unsafe.Pointer len int cap int } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:1:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"声明和初始化 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:2:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"使用make函数创建 使用内置的make函数，第一个参数用于指定切片长度，第二参数用于指定切片容量。如果不指定容量，那么容量默认与长度相同。 slice1 := make([]int, 5) slice2 ：= make([]int, 5, 10) 在slice2中只能访问5个元素，因为切片长度为5，剩下5个元素，需要切片扩充后才能访问。 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:2:1","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"使用字面量创建 slice3 := []int{1, 2, 3, 4, 5} slice4 := []int{4:1} ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:2:2","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"基于原数组或切片创建 slice5 := []int{1, 2, 3, 4, 5} slice6 := slice5[:] slice7 := slice5[0:] slice8 := slice5[:5] [i:j]是从i开始，但不包括j i省略则默认0，j省略则默认为长度，i,j 都应该在范围内， i\u003e=0, j \u003c=size 新切片和旧切片共享同一个底层数组，一荣俱荣，一损俱损 func testSlice() { var originArr [5]int slice1 := originArr[:] slice2 := originArr[:2] originArr[2] = 4 fmt.Println(slice1) fmt.Println(slice2) slice2[1] = 5 fmt.Println(slice1) fmt.Println(slice2) slice3 := []int{1, 2, 3, 4, 5}[:] slice4 := []int{1, 2, 3, 4, 5}[:] slice4[3] = 9 fmt.Println(slice3) fmt.Println(slice4) //slice1,2共享底层数组，但slice3,4不共享底层数组 } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:2:3","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片长度、容量 切片长度：len(slice) 切片容量：cap(slice) 将切片s的长度拓展到容量上限：s = s[:cap(s)] make([]int, length, capactiy), s[start🔚capacityend]可操作修改容量，具体地见如下代码 package main import ( \"fmt\" ) func main() { // capacityend needs to be less than or equal to the basical capacity slice1 := make([]int, 5, 10) slice2 := slice1[:6] slice3 := slice1[:6:8] // 8 \u003c= cap(slice1) slice4 := slice1[4:5:10] // 10 \u003c= cap(slice1) slice5 := slice2[1:] slice6 := slice3[2:] slice7 := slice3[2::6] // 6 \u003c= cap(slice3) fmt.Printf(\"capacity of slice1 is %d\\n\", cap(slice1)) //10 fmt.Printf(\"capacity of slice2 is %d\\n\", cap(slice2)) //10 fmt.Printf(\"capacity of slice3 is %d\\n\", cap(slice3)) //8 = 8-0 fmt.Printf(\"capacity of slice4 is %d\\n\", cap(slice4)) //6 = 10-4 fmt.Printf(\"capacity of slice5 is %d\\n\", cap(slice5)) //9 = cap(slice2) - 1 fmt.Printf(\"capacity of slice6 is %d\\n\", cap(slice6)) //6 = cap(slice3) - 2 fmt.Printf(\"capacity of slice7 is %d\\n\", cap(slice7)) //4 = 6- 2 } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:3:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"特殊切片 nil切片和空切片长度和容量都是0，但nil切片指向底层数组的指针是nil，而空切片对应的是一个地址。 package main import ( \"fmt\" ) func main() { var nilSlice []int var empytSlice = []int{} fmt.Println(len(nilSlice), cap(nilSlice)) fmt.Println(len(empytSlice), cap(empytSlice)) } // 0 0 // 0 0 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:4:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"扩充切片 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:5:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"在容量范围内，修改切片长度 切片只能访问到其长度内的元素，访问超过元素外的元素，会导致运行时异常。 package main import \"fmt\" func main() { slice1 := make([]int, 0, 10) fmt.Printf(\"slice1:%d %d\\n\", len(slice1), cap(slice1)) slice2 := slice1[5:7] fmt.Printf(\"slice2:%d %d\\n\", len(slice2), cap(slice2)) slice3 := slice2[:len(slice2)+1] fmt.Printf(\"slice3:%d %d\\n\", len(slice3), cap(slice3)) slice4 := slice2[:cap(slice2)] fmt.Printf(\"slice2:%d %d\\n\", len(slice4), cap(slice4)) } // slice1:0 10 // slice2:2 5 // slice3:3 5 // slice2:5 5 注意：不同向前移动，只能向下标增大的方向获取底层数组剩下的元素 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:5:1","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"增加切片的容量 package main import ( \"fmt\" ) func main() { nums1 := make([]int, 5) fmt.Println(cap(nums1), len(nums1)) fmt.Printf(\"the address of nums in modify is %p\\n\", \u0026nums1) nums1 = append(nums1, 6) fmt.Println(cap(nums1), len(nums1)) fmt.Printf(\"the address of nums in modify is %p\\n\", \u0026nums1) nums2 := make([]int, 5, 10) for i := range nums2 { nums2[i] = i + 1 } fmt.Println(cap(nums2), len(nums2)) fmt.Printf(\"the address of nums in modify is %p\\n\", \u0026nums2) nums2 = append(nums2, 6) fmt.Println(cap(nums2), len(nums2)) fmt.Printf(\"the address of nums in modify is %p\\n\", \u0026nums2) } //5 5 //the address of nums in modify is 0xc000004078 //10 6 //the address of nums in modify is 0xc000004078 //10 5 //the address of nums in modify is 0xc000004090 //10 6 //the address of nums in modify is 0xc000004090 首先看这份代码，可以看到nums1长度为5，容量为5，没有位置去加入元素6，所以使用append函数后，扩充了容量。而对于nums2长度为5，容量为10，只需增加长度即可。此外，nums1和nums2的地址都没有变，说明它们还是原来那个切片，但nums1指向的底层数组已经发生改变，而nums2没有。 append函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25。若切片底层数组还有容量，则在原数组上操作；若切片底层数组没有足够的容量时，就会创建一个新底层数组，把原来数组的值复制到新底层数组里，再追加新值，而且这样不会影响原来的底层数组，实例如下： package main import \"fmt\" func main() { slice1 := make([]int, 5) slice2 := slice1 slice1[0] = 1 fmt.Println(slice1, slice2) slice2 = append(slice2, 6) fmt.Println(slice1, slice2) slice1[2] = 3 fmt.Println(slice1, slice2) } // [1 0 0 0 0] [1 0 0 0 0] // [1 0 0 0 0] [1 0 0 0 0 6] // [1 0 3 0 0] [1 0 0 0 0 6] 因此，一般在创建新切片的时候，最好要让新切片的长度和容量一样，这样在追加操作的时候就会生成新的底层数组，和原有数组分离，就不会因为共用底层数组而引起奇怪问题。因为共用数组的时候修改内容，会影响多个切片。 或者直接使用copy函数进行深拷贝，这样就不会共享同一个底层数组。 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:5:2","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"append操作 内置的append 也是一个可变参数的函数，所以可以同时追加好几个值，也可以通过...操作符，把一个切片追加到另一个切片里面。 a = append(a, x, y, z) //末尾添加元素x y z x, a = a[len(a)-1], a[:len(a)-1] //去除切片a最末尾的元素x a = append(a, b...) //将切片b中的所有元素加入a a = append(a[:i], a[j:]...) //删除切片a中i,i+1..j-1的元素 a = append(a[:i], append(b, a[i:]...)...) //索引i的位置插入切片b的所有元素 a = append(a, make([]T, j)...) //为切片a拓展j个元素长度 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:6:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片的使用 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:7:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片迭代 package main import ( \"fmt\" ) func main() { cities := []string{\"shanghai\", \"beijing\", \"shaanxi\"} for _, city := range cities { fmt.Println(city) } for i := 0; i \u003c len(cities); i++ { fmt.Println(cities[i]) } } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:7:1","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片作为函数参数 值传递与引用传递：https://zhuanlan.zhihu.com/p/366908019 切片作为参数，在函数间以传递的方式传递，占用内存非常小。在传递赋值切片时，底层数组不会被赋值，不受影响。 package main import ( \"fmt\" ) func main() { nums := []int{1, 2, 3, 4, 5} fmt.Printf(\"the address of nums in main is %p\\n\", \u0026nums) modify(nums) fmt.Println(nums) } func modify(nums []int) { fmt.Printf(\"the address of nums in modify is %p\\n\", \u0026nums) nums[0] = 10 } // the address of nums in main is 0xc000004078 // the address of nums in modify is 0xc000004090 // [10 2 3 4 5] 可以发现这两个切片地址不一样，这是因为两个num保存的是切片的地址，对nums取地址得到的是nums的地址，而不是底层数组。在修改一个索引的值后，原切片的值也被修改了，说明其共用一个底层数组。 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:7:2","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片拷贝 正如在切片作为函数参数中所说，切片作为参数时是值传递的。将切片赋值给另一个切片时，它们之间是共享底层数组的，实例如下： package main import \"fmt\" func main() { a := []int{1, 2, 3} b := a fmt.Println(a, b) b[0] = 22 fmt.Println(a, b) } // [1 2 3 ] [1 2 3] // [22 2 3] [22 2 3] 如果想要互不影响的话，可以使用copy函数 func copy(dst, src []T) int ：copy方法将类型为T的切片从源地址src拷贝到目标地址dst，覆盖dst的相关元素，并且返回拷贝的元素的个数，其中拷贝个数是src和dst长度的最小值。 package main import \"fmt\" func main() { a := []int{1, 2, 3} b := make([]int, len(a)) copy(b, a) a[0] = -2 b[0] = 2 fmt.Println(a, b) } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:7:3","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"垃圾回收 切片的底层指向一个数组，但该数组的实际容量可能要大于切片所定义的容量。 只有在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存。 示例，函数FindDigits将一个文件加载到内存，然后搜索正则表达式的第一个匹配项（这里是数字）并返回一个切片。 var digitRegexp = regexp.MustCompile(\"[0-9]+\") func FindDigits(filename string) []byte{ b, _ := ioutil.ReadFile(filename) return digitRegexp.Find(b) } 这段代码可以顺利运行，但返回的[]byte指向的底层是整个文件的数据。只要该切片不被释放，垃圾回收器就不能释放整个文件所占用的内存。换句话说，这一点点有用的数据却占用了整个文件的内存。 修改后的代码如下： var digitRegexp = regexp.MustCompile(\"[0-9]+\") func FindDigits(filename string) []byte{ b, _ := ioutil.ReadFile(filename) b = digitRegexp.Find(b) c := make([]byte, len(b)) copy(c, b) return c } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:8:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"切片练习 ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:9:0","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"增加切片容量的函数 func AppendByte(slice []byte, data ...byte) []byte { m := len(slice) n := m + len(data) if n \u003e cap(slice) { newSlice := make([]byte, (n + 1) * 2) copy(newSlice, slice) slice = newSlice } slice = slice[0:n] copy(slice[m:n], data) return slice } ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:9:1","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"写一个函数InsertStringSlice将切片插入到另一个切片的指定位置 func main() { s3 := make([]byte, 5, 15) s3[0], s3[1], s3[2], s3[3], s3[4] = 'h', 'e', 'l', 'l', 'o's4 := []byte(\"test\") ans, _ := insertStringSlice(s3, s4, 2) fmt.Println(string(ans)) s1 := []byte(\"helloworld\") s2 := []byte(\"testing\") ans2, _ := insertStringSlice(s1, s2, 2) fmt.Println(string(ans2)) } func insertStringSlice(dst, data []byte, pos int) ([]byte, bool) { if pos \u003c 0 || pos \u003e len(dst) { return nil, false } err := true n := len(dst) + len(data) if n \u003c= cap(dst) { dst = dst[:n] } else { newSlice := make([]byte, n) copy(newSlice, dst) dst = newSlice } copy(dst[pos+len(data):], dst[pos:]) copy(dst[pos:pos+len(data)], data) return dst, err } //hetestllo //heftestinglloworld ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:9:2","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":"写一个函数RemoveStringSlice将从start到end索引的元素从切片中移除 func main() { nums := []int{1, 2, 3, 4, 5, 6, 7} fmt.Println(removeStringSlice(nums, 3, 6)) } func removeStringSlice(nums []int, start, end int) ([]int, bool) { if start \u003c 0 || end \u003e= len(nums) { return nil, false } copy(nums[start:], nums[end+1:]) n := len(nums) nums = nums[:n-(end-start+1)] return nums, true } // [1, 2, 3] true ","date":"2022-01-16","objectID":"/2022/01/go-ch12/:9:3","tags":null,"title":"Ch12 切片","uri":"/2022/01/go-ch12/"},{"categories":["golang"],"content":" 数组是同一种数据类型元素的集合 数组是切片、Map等数据结构的基础 在Go语言中，数组从声明时就已经确定数组中元素的类型和个数，在程序运行期间不可变 数组的最大长度是2GB ","date":"2022-01-10","objectID":"/2022/01/go-ch11/:0:0","tags":null,"title":"Ch11 数组","uri":"/2022/01/go-ch11/"},{"categories":["golang"],"content":"1 数组定义 var identifier [len]type 例如， var arr1 [3]int var arr2 [5]int 数组的长度必须是常量，并且长度是数组类型的一部分，一旦确定，不能改变。 此外，[3]int和[5]int是不同的类型。 ","date":"2022-01-10","objectID":"/2022/01/go-ch11/:1:0","tags":null,"title":"Ch11 数组","uri":"/2022/01/go-ch11/"},{"categories":["golang"],"content":"2 数组初始化 var arr1 [3]int //[0,0,0] var arr2 [3]int{1,2} //[1,2,0] var arr3 [3]string{\"beijing\", \"shanghai\", \"shenzhen\"} //[北京,上海,深圳] var arr4 = [...]int{1,2} //[1,2] var arr5 = [...]int{1:1, 3:5} //[0,1,0.5] var arr6 = [3][2]string{ {\"北京\", \"上海\"}, {\"广州\", \"深圳\"}, {\"成都\", \"重庆\"}, } var arr7 = [...][2]string{ {\"北京\", \"上海\"}, {\"广州\", \"深圳\"}, {\"成都\", \"重庆\"}, } 当[]为空，而不是...时，此时的类型是slice 多维数组中，只有第一层可以使用...让编译器来推导数组长度 ","date":"2022-01-10","objectID":"/2022/01/go-ch11/:2:0","tags":null,"title":"Ch11 数组","uri":"/2022/01/go-ch11/"},{"categories":["golang"],"content":"3 数组遍历 for i := 0; i \u003c len(arr1); i++ { fmt.Println(arr1[i]) } for idx, value := range arrr1 { fmt.Println(idx, value) } for i := 0; i \u003c len(arr6); i++ { for j := 0; j \u003c len(arr6[i]); j++ { fmt.Println(arr6[i][j]) } fmt.Println() } for _, rows := range arr6 { for _, city := range rows { fmt.Println(city) } fmt.Println() } ","date":"2022-01-10","objectID":"/2022/01/go-ch11/:3:0","tags":null,"title":"Ch11 数组","uri":"/2022/01/go-ch11/"},{"categories":["golang"],"content":"4 指针数组和数组指针 指针数组和数组本身差不多，只不过元素类型是指针。 package main import \"fmt\" func main() { array := [5]*int{1:new(int), 3:new(int)} // 至此只能给下标位1,3的解引用，对nil解引用会使得系统崩溃 // 不能对空指针解引用 for idx, p := range array { if p != nil { fmt.Println(idx, *p) } else { fmt.Println(\"nil\") } } *array[1] = 1 array[0] = new(int) *array[0] = 2 fmt.Println(\"after......\") for idx, p := range array { if p != nil { fmt.Println(idx, *p) } else { fmt.Println(\"nil\") } } } 数组是值类型，传参时会复制整个数组，改变副本的值而不改变本身的值。将数组作为参数传递给函数时，如果需要对数组进行修改，并将结果保留，可以使用以下两种方式 关于切片和关于函数将在ch12 切片和ch13 函数说明 使用指针 注意这里不能用for-range结构遍历修改数组,具体原因参考ch8 控制结构 package main import ( \"fmt\" ) func main() { array := [3]float64{7.0, 8.5, 9.1} fmt.Println(array) modifyArr(\u0026array) fmt.Println(array) } func modifyArr(arr *[3]float64) { for i := 0; i \u003c 3; i++ { if (*arr)[i] \u003e 5.0 { (*arr)[i] = 5.0 } //if arr[i] \u003e 5.0 { // arr[i] = 5.0 //} //语法糖，与上面等价，隐藏了间接引用 } } 使用切片 package main import ( \"fmt\" ) func main() { array := [3]float64{7.0, 8.5, 9.1} fmt.Println(array) modifyArr(array[:]) fmt.Println(array) } func modifyArr(arr []float64) { for i := 0; i \u003c 3; i++ { if arr[i] \u003e 5.0 { arr[i] = 5.0 } } } ","date":"2022-01-10","objectID":"/2022/01/go-ch11/:4:0","tags":null,"title":"Ch11 数组","uri":"/2022/01/go-ch11/"},{"categories":["golang"],"content":"值类型，如：int、float、bool、string、array、struct 引用类型，如：ptr（指针）, slice、map、channel、func、interface 值类型：值类型变量存储在栈中。 var i int = 7 var j = i 使用=将一个变量的值赋值给另一个变量时，实际上是在内存中将i的值进行了拷贝 引用类型：被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。 更复杂的数据，例如ptr、slice、map、channel、func、interface通常会需要使用多个字，这些数据一般使用引用类型保存。 package main import \"fmt\" func main() { var r1 int = 20 var x, y *int = \u0026r1, \u0026r1 fmt.Println(*x, *y) } 一个引用类型的变量x 存储的是r1的值所在的内存地址，或者内存地址中第一个字所在的位置。一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 ","date":"2021-12-24","objectID":"/2021/12/go-ch10/:0:0","tags":null,"title":"Ch10 值类型与引用类型","uri":"/2021/12/go-ch10/"},{"categories":["golang"],"content":"与C++不同的是，Go语言为程序员提供了控制数据结构指针的能力，但却不支持指针运算。 通过给予程序员基本内存布局，Go 语言允许控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的。 ","date":"2021-12-19","objectID":"/2021/12/go-ch9/:0:0","tags":null,"title":"Ch9 指针","uri":"/2021/12/go-ch9/"},{"categories":["golang"],"content":"1 指针的含义 声明变量的过程就是向系统申请内存的过程。如果在程序中声明了一个变量，那么操作系统会分配一块内存，此后就可以通过变量名在这块内存中存储、修改值。 该内存在操作系统中是有地址的，可以通过取地址符\u0026来获得这个地址，把这个地址信息存在另一个变量中，这个变量就叫做指针。 内存地址通常用十六进制表示，32位机器4个字节，64位机器8个字节 当一个指针被定义后没有分配到任何变量时，它的值位nil *ptr，可获得ptr指向地址上所存储的值，这被称为反引用或解引用（dereference） package main import \"fmt\" func main() { var num = 5 fmt.Printf(\"An integer: %d, its location in memory: %p\\n\", num, \u0026num) var numPtr *int numPtr = \u0026i1 fmt.Printf(\"The value at memory location %p is %d\\n\", numPtr, *numPtr) } //An integer: 5, its location in memory: 0x24f0820 //The value at memory location 0x24f0820 is 5 下面的程序，通过指针修改了原字符串s package main import \"fmt\" func main() { s := \"good bye\" var p *string = \u0026s *p = \"ciao\" fmt.Printf(\"Here is the pointer p: %p\\n\", p) // prints address fmt.Printf(\"Here is the string *p: %s\\n\", *p) // prints string fmt.Printf(\"Here is the string s: %s\\n\", s) // prints same string } //Here is the pointer p: 0x2540820 //Here is the string *p: ciao //Here is the string s: ciao 在本节开头提到不支持指针运算指的是p++,p--这种,这些运算是不被允许的。 #include \u003ciostream\u003eusing namespace std; int main() { int arr[5] = {1, 2, 3, 4 ,5}; for(int *p = arr; p \u003c arr+5; p++) { cout \u003c\u003c *p \u003c\u003c endl; } return 0; } 注意事项 警告 不能获取常量（字面量也是常量）的地址。 const i = 5 ptr := \u0026i //error: cannot take the address of i ptr2 := \u002610 //error: cannot take the address of 10 警告 对空指针的解引用不合法，会使程序崩溃。 package main func main() { var p *int = nil *p = 0 } // in Windows: stops only with: \u003cexit code=\"-1073741819\" msg=\"process crashed\"/\u003e // runtime error: invalid memory address or nil pointer dereference ","date":"2021-12-19","objectID":"/2021/12/go-ch9/:1:0","tags":null,"title":"Ch9 指针","uri":"/2021/12/go-ch9/"},{"categories":["golang"],"content":"2 指针的利弊 好处：传参时，可以传一个指针，而不是变量的拷贝，可以减少内存占用和提高效率。 坏处：指针的过度频繁使用也可能导致性能下降。指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致可以有多级的间接引用，但在大多数情况这会使代码结构不清晰。 ","date":"2021-12-19","objectID":"/2021/12/go-ch9/:2:0","tags":null,"title":"Ch9 指针","uri":"/2021/12/go-ch9/"},{"categories":["golang"],"content":"3 语法糖 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 在大多数情况下 Go 语言可以使程序员轻松创建指针，并且隐藏间接引用，即自动解引用。在之后的结构体之中体现的更加明显，这是Go语言支持的一个语法糖。 stu是一个student结构体的指针，要调用成员变量，应为(*stu).age，但Go语言内部支持stu.age这种方式，能支持这种方式调用的本质原因是Go不支持对指针的修改，具体会在结构一章再次进行说明。 ch18 自定义类型与结构体 packge main import \"fmt\" type Student struct { Age int Name string } func main() { stu := \u0026Student{19, \"Tony\"} fmt.Println(stu.age) fmt.Println((*stu).age) } ","date":"2021-12-19","objectID":"/2021/12/go-ch9/:3:0","tags":null,"title":"Ch9 指针","uri":"/2021/12/go-ch9/"},{"categories":["golang"],"content":"1 条件结构和分支结构 ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:1:0","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"1.1 if-else 习惯用法一 var prompt = \"Enter a digit, e.g. 3 \"+ \"or %s to quit.\" func init() { if runtime.GOOS == \"windows\" { prompt = fmt.Sprintf(prompt, \"Ctrl+Z, Enter\") } else { //Unix-like prompt = fmt.Sprintf(prompt, \"Ctrl+D\") } } 习惯用法二 ok-pattern模式 if语句可包含一个初始化语句，例如给一个变量赋值 if val := 10; val \u003e max { // do something } 使用简短方式:=声明的变量val，其作用域只存在于if语句中，包括if后的else语句。 如果变量val在if结构之前已经存在，那么在if语句块中，该变量原来的值会被隐藏。 if value := process(data); value \u003e max { // do something } value, err := pack1.Function1(param1) if err != nil { fmt.Printf(\"An error occured in pack1.Function1 with parameter %v\", param1) return err } 使用习惯语法二，可将上述代码简化为，这种方式常称为ok-pattern模式 if value, err := pack1.Function1(param1); err != nil { fmt.Printf(\"An error occured in pack1.Function1 with parameter %v\", param1) return err } ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:1:1","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"1.2 switch结构 switch var1 { case value1: ... case value2: ... default: ... } value1和value2必须是相同类型的值或计算结果为相同类型的表达式 与C语言一样，case后可跟多个可能符合条件的值，使用逗号分割 Golang使用快速的查找算法来测试switch条件与case分支的匹配清空，直到算法匹配到某个case或进入default为止 某个分支的代码执行完毕后，会退出整个switch代码块。如果希望执行后续分支的代码，可以使用fallthrough关键字 在 case ...: 语句之后，不需要使用花括号将多行语句括起来，当代码块只有一行时，可以直接放置在 case 语句之后。 习惯用法一 package main import \"fmt\" func main() { var num1 int = 100 switch num1 { case 98, 99: fmt.Println(\"It's equal to 98\") case 100: fmt.Println(\"It's equal to 100\") default: fmt.Println(\"It's not equal to 98 or 100\") } } 习惯用法二 switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 if-else 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。 package main import \"fmt\" func main() { var num1 int = 7 switch { case num1 \u003c 0: fmt.Println(\"Number is negative\") case num1 \u003e 0 \u0026\u0026 num1 \u003c 10: fmt.Println(\"Number is between 0 and 10\") default: fmt.Println(\"Number is 10 or greater\") } } 习惯用法三 switch 语句的第三种形式是包含一个初始化语句，这种形式可以非常优雅地进行条件判断。在下面这个代码片段中，变量 a 和 b 被平行初始化，然后作为判断条件： switch a, b := x[i], y[j]; { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } 此外，如果初始化语句出现赋值失败的情况，例如如下的语句，这种情况需要自己额外注意会不会引入意向不到的BUG。 package main import \"fmt\" var scores = map[string]int{\"Tony\": 95, \"Tom\": 59, \"Sarah\": 79} func main() { switch score := scores[\"Lisa\"]; { case score \u003e 90: fmt.Println(score) fmt.Println(\"excellent\") case score \u003e 80: fmt.Println(\"Pretty good\") case score \u003e 60: fmt.Println(\"not bad\") default: fmt.Println(\"failed\") } } // Lisa doesn't exist, but this program still output failed otherwise 'unknown student'. ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:1:2","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"2 迭代或循环结构 ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:2:0","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"2.1 for 习惯用法一 变量i package main import \"fmt\" func main() { for i := 0; i \u003c 5; i++ { fmt.Printf(\"This is the %d iteration\\n\", i) } } 警告 特别注意, 永远不要在循环体内修改计数器，这在任何语言中都是非常差的实践！ 得益于 Go 语言具有的平行赋值的特性,==可以在循环中同时使用多个计数器：== for i, j := 0, N; i \u003c j; i, j = i+1, j-1 { // do something } 习惯用法二 基于条件判断的迭代 for 结构的第二种形式是没有头部的条件判断迭代（类似其它语言中的 while 循环），基本形式为：for 条件语句 {}。 package main import \"fmt\" func main() { var i int = 5 for i \u003e= 0 { i = i - 1 fmt.Printf(\"The variable i is now: %d\\n\", i) } } 习惯用法三 无限循环 条件语句是可以被省略的，如 i:=0; ; i++ 或 for { } 或 for ;; { }（;; 会在使用 gofmt 时被移除）：这些循环的本质就是无限循环。最后一个形式也可以被改写为 for true { }，但一般情况下都会直接写 for { }。 如果 for 循环的头部没有条件语句，那么就会认为条件永远为 true，因此循环体内必须有相关的条件判断以确保会在某个时刻退出循环。想要直接退出循环体，可以使用 break 语句或 return 语句直接返回。 无限循环的经典应用是服务器，用于不断等待和接受新的请求。 ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:2:1","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"2.2 for range 这是 Go的一种迭代结构，它可以迭代任何一个集合（包括数组和 map等）。 一般形式为：for ix, val := range coll { }。 警告 要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值，但如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值。 package main import \"fmt\" func main() { arr := []int{0, 1, 2, 3} for i, val := range arr { val = val * i fmt.Printf(\"in the loop, %dth element of arr is %d\\n\", i, val) } for i, val := range arr { fmt.Printf(\"after modify operation, %dth element of arr is %d\\n\", i, val) } matrix := [][]int{{1, 2, 3}, {4, 5, 6}} for _, row := range matrix { row[0] += row[0] } fmt.Println(matrix) } //in the loop, 0th element of arr is 0 //in the loop, 1th element of arr is 1 //in the loop, 2th element of arr is 4 //in the loop, 3th element of arr is 9 //after modify operation, 0th element of arr is 0 //after modify operation, 1th element of arr is 1 //after modify operation, 2th element of arr is 2 //after modify operation, 3th element of arr is 3 //[[1 2 3] [16 5 6]] ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:2:2","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"2.3 break、continue break：作用范围为该语句最后出现的内部结构，如for、switch、select continue： 忽略剩余的循环体，直接进行下一次是否进入循环的判断，只用于for ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:2:3","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"2.4 label、goto 正常continue情况下，continue只忽视内层循环，还应输出i is: 0, and j is : 5的结果，但这里直接使 i 变成下一个循环的值，而此时 j 的值就被重设为 0。 func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } //i is: 0, and j is: 0 //i is: 0, and j is: 1 //i is: 0, and j is: 2 //i is: 0, and j is: 3 //i is: 1, and j is: 0 //i is: 1, and j is: 1 //i is: 1, and j is: 2 //i is: 1, and j is: 3 //.. 将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环。 func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { break LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } // i is: 0, and j is: 0 // i is: 0, and j is: 1 // i is: 0, and j is: 2 // i is: 0, and j is: 3 标签和goto语句是不被鼓励的，只建议使用 goto 语句来跳出无限读取循环并关闭相应的客户端链接。 如果必须使用 goto，应当只使用正序的标签（标签位于 goto 语句之后），但注意标签和 goto 语句之间不能出现定义新变量的语句，否则会导致编译失败。 // compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8 package main import \"fmt\" func main() { a := 1 goto TARGET // compile error b := 9 TARGET: b += a fmt.Printf(\"a is %v *** b is %v\", a, b) } ","date":"2021-12-16","objectID":"/2021/12/go-ch8/:2:4","tags":null,"title":"Ch8 控制结构","uri":"/2021/12/go-ch8/"},{"categories":["golang"],"content":"在初学时，初步掌握命令行参数、使用Scan族函数读取Stdin，使用Print族函数向Stdout输出即可，关于输入输出更多的操作，请参考ch28 进阶输入输出 ","date":"2021-12-14","objectID":"/2021/12/go-ch7/:0:0","tags":null,"title":"Ch7 输入与输出","uri":"/2021/12/go-ch7/"},{"categories":["golang"],"content":"1 命令行参数 os以跨平台的方式，提供了一些与操作系统交互的函数和变量，程序的命令行参数可以从os包中的Args变量获取。os.Args是一个字符串类型的切片[]string，其中os.Args[0]是文件名，其他元素是程序启动时传给它的参数。 package main import ( \"os\" \"fmt\" ) func main() { str := \"\" for _, v := range os.Args { str += \" \" str += v } fmt.Println(str) } ","date":"2021-12-14","objectID":"/2021/12/go-ch7/:1:0","tags":null,"title":"Ch7 输入与输出","uri":"/2021/12/go-ch7/"},{"categories":["golang"],"content":"2 Scan族函数 可使用fmt包提供的Scan开头的函数，从键盘和标准输入os.Stdin中读取输入 注意！Scan类无法读取空格，空格会被视为两个参数之间的分隔 Scan: 读入，直到全部得到参数 package main import \"fmt\" func main() { var a string var b int fmt.Scan(\u0026a, \u0026b) fmt.Println(a, b) } // input: hello world 直接结束了，不给输入int值的机会 // output: hello 0 Scanf：必须严格按照此输入模式 若格式化串内含有回车，则在键盘输入时，必须有相应的回车相对应。 格式化串内的空格数目和输入中的空格数目没有影响。 package main import \"fmt\" func main() { var a string var b int fmt.Scanf(\"%s \\n %d\", \u0026a, \u0026b) fmt.Println(a, b) } // input: hello // 1 // output: hello 1 // input: hello 1 // output: hello 0 Scanln扫描来自标准输入中一行的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。 如果扫描到的值小于参数数目，则直接结束，未被赋值的参数仍为原来的值（或默认值）。 如果扫描到的值多于参数数目，会出现奇怪的问题，见下文代码。 package main import \"fmt\" func main() { var a, b, c int fmt.Scanln(\u0026a, \u0026b, \u0026c) fmt.Println(a, b, c) } // input: 1 2 // output: 1 2 0 2之后遇到回车不会继续等待输入，结束Scanln语句 // input: 1 2 3 // output: 1 2 3 // input: 1 2 3 4 // output: 1 2 3 package main import \"fmt\" func main() { var a, b, c, d, e int fmt.Scanln(\u0026a, \u0026b, \u0026c) fmt.Println(a, b, c) fmt.Scanln(\u0026d, \u0026e) fmt.Println(d, e) } // input: 1 2 3 4 5 // output: 1 2 3 // 5 0 // 出现此结果的原因，可能是Scanln将输入缓冲区中的4修改成为了换行符 // 因此，为了正确的输入，输入4，5时必须在换行符之后 ","date":"2021-12-14","objectID":"/2021/12/go-ch7/:2:0","tags":null,"title":"Ch7 输入与输出","uri":"/2021/12/go-ch7/"},{"categories":["golang"],"content":"3 Print族函数 可使用fmt包提供的Print开头的函数，可向键盘和标准输出os.Stdout中进行输出 Printf，输出格式化的字符串 常见占位符如下， %b、%d、%o、%x(%X)：二进制、十进制、八进制、十六进制表示 %c：相应Unciode码点所表示的字符 %s：字符串 %t：布尔 %g：浮点数 %p：指针，十六进制表示 %T：值的类型 %v：值的默认格式 bool: %t int, int8 etc.: %d uint, uint8 etc.: %d, %x if printed with %#v float32, complex64, etc: %g string: %s chan: %p pointer: %p ​ 具体示例如下： package main import \"fmt\" func main() { a := 20 b := 3.14 c := \"hi, Bruce\" d := true e := 3 + 4i f := 's' fmt.Printf(\"a:%v, %T, %d\\n\", a, a, a) fmt.Printf(\"b:%v, %T, %f\\n\", b, b, b) fmt.Printf(\"c:%v, %T, %s\\n\", c, c, c) fmt.Printf(\"d:%v, %T, %t\\n\", d, d, d) fmt.Printf(\"e:%v, %T, %g\\n\", e, e, e) fmt.Printf(\"f:%v, %T, %c\\n\", f, f, f) } // a:20, int, 20 // b:3.14, float64, 3.140000 // c:hi, Bruce, string, hi, Bruce // d:true, bool, true // e:(3+4i), complex128, (3+4i) // f:115, int32, s Print等价于对每一个操作数都应用%v Println 应用%v输出到控制台并换行 ","date":"2021-12-14","objectID":"/2021/12/go-ch7/:3:0","tags":null,"title":"Ch7 输入与输出","uri":"/2021/12/go-ch7/"},{"categories":["golang"],"content":"1 常量 每个常量的潜在类型都是基础类型：布尔、字符串或数字 常量的声明语句定义了常量的名字和数值 常量的值在运行期间不可修改 常量表达式的值在编译期计算，而不是运行期 常量间的运算、包括算术运算、逻辑运算和比较运算的结果都是常量，对常量的类型转换操作或以下函数调用结果也是常量：len、cap、real、imag、complex、和unsafe.Sizeof 常量或常量表达式的值可以构成类型的一部分，例如数组长度 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:0","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1. 1 Typed and Untyped Constants 引用 以下英文内容摘抄自：https://blog.csdn.net/pengpengzhou/article/details/107561792 众所周知，Go是强类型语言，在编译期间每一个变量的类型都是已知或可推导的。此外，即使是int64类型和int32类型的变量相加也需要进行强类型转换。 var myFloat float64 = 21.54 var myInt int = 562 var myInt64 int64 = 120 // var res1 = myFloat + myInt // Not allowed // var res2 = myInt + myInt64 // Not allowed var res1 = myFloat + float64(myInt) var res2 = myInt + int(myInt64) 但，如下的代码却是合法的，不需要对10进行强制类型转换，其中的原因在于Golang对于常量的处理 var myInt32 int32 = 10 var myInt int = 10 var myFloat64 float64 = 10 var myComplex complex64 = 10 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:1","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.2 Untyped Constants Golang中的任何一个常量，除非人为设置一个类型，否则无论是有名常量（用const定义的）还是无名常量（字面量）都是untyped 1 // untyped integer constant 4.5 // untyped floating-point constant true // untyped boolean constant \"Hello\" // untyped string constant // 或者如下定义 const a = 1 // untyped integer constant const f = 4.5 // untyped floating-point constant const b = true // untyped boolean constant const s = \"Hello\" // untyped string constant You may be confused that I’m using terms like integer constant, and I’m also saying that it is untyped. Well yes, the value 1 is an integer, 4.5 is a float, and \"Hello\" is a string. But they are just values. They are not given a fixed type yet, like int32 or float64 or string, that would force them to obey Go’s strict type rules. The fact that the value 1 is untyped allows us to assign it to any variable whose type is compatible with integers（string and boolean are not included) var myInt int = 1 var myFloat float64 = 1 var myComplex complex64 = 1 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:2","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.3 Constants and Type inference：Default Type Go supports type inference. That is, it can infer the type of a variable from the value that is used to initialize it. So you can declare a variable with an initial value, but without any type information, and Go will automatically determine the type var a = 5 // Go compiler automatically infers the type of the variable `a` But how does it work? Given that constants in Golang are untyped, what will be the type of the variable a in the above example? Will it be int8 or int16 or int32 or int64 or int? Well, it turns out that every untyped constant in Golang has a default type. The default type is used when we assign the constant to a variable that doesn’t have any explicit type available. Following are the default types for various constants in Golang integers (10, 76) int floats (3.14, 7.92) float64 complex numbers (3+5i) complex128 characters (`'a'`, `'♠'`) rune booleans (true, false) bool strings (“Hello”) sting So, in the statement var a = 5, since no explicit type information is available, the default type for integer constants is used to determine the type of a, which is int. ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:3","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.4 Typed Constants In Golang, Constants are typed when you explicitly specify the type in the declaration like this const typedInt int = 1 // Typed constant Just like variables, all the rules of Go’s type system applies to typed constant. For example, you cannot assign a typed integer constant to a float variable var myFloat64 float64 = typedInt // Compiler Error With typed constants, you lose all the flexibility that comes with untyped constants like assigning them to any variable of compatible type or mixing them in mathematical operations. So you should declare a type for a constant only if it’s absolutely necessary. Otherwise, just declare constants without a type. ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:4","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.5 Constant Expressions The fact that constants are untyped (unless given a type explicitly) allows you to mix them in any expression freely. So you can have a contant expression containing a mix of various untyped constants as long as those untyped constants are compatible with each other const a = 5 + 7.5 // Valid const b = 12/5 // Valid const c = 'z' + 1 // Valid const d = \"Hey\" + true // Invalid (untyped string constant and untyped boolean constant are not compatible with each other) The evaluation of constant expressions and their result follows certain rules. Let’s look at those rules Rules for constant expressions A comparison operation between two untyped constants always outputs an untyped boolean constant. const a = 7.5 \u003e 5 // true (untyped boolean constant) const b = \"xyz\" \u003c \"uvw\" // false (untyped boolean constant) For any other operation (except shift) If both the operands are of the same type (ex - both are untyped integer constants), the result is also of the same type. For example, the expression 25/2 yields 12 not 12.5. Since both the operands are untyped integers, the result is truncated to an integer. If the operands are of different type, the result is of the operand’s type that is broader as per the rule: integer \u003c rune \u003c floating-point \u003c complex. const a = 25/2 // 12 (untyped integer constant) const b = (6+8i)/2 // (3+4i) (untyped complex constant) Shift operation rules are a bit complex. First of all, there are some requirements The right operand of a shift expression must either have an unsigned integer type or be an untyped constant that can represent a value of type uint. The left operand must either have an integer type or be an untyped constant that can represent a value of type int The rule - If the left operand of a shift expression is an untyped constant, the result is an untyped integer constant; otherwise the result is of the same type as the left operand. const a = 1 \u003c\u003c 5 // 32 (untyped integer constant) const b = int32(1) \u003c\u003c 4 // 16 (int32) const c = 16.0 \u003e\u003e 2 // 4 (untyped integer constant) - 16.0 can represent a value of type `int` const d = 32 \u003e\u003e 3.0 // 4 (untyped integer constant) - 3.0 can represent a value of type `uint` const e = 10.50 \u003c\u003c 2 // ILLEGAL (10.50 can't represent a value of type `int`) const f = 64 \u003e\u003e -2 // ILLEGAL (The right operand must be an unsigned int or an untyped constant compatible with `uint`) 摘要 在上述的英文内容中，说明了常量的两种类型 Untyped Constants 和 Typed Constants Untyped Constants：实质上就是指字面量，即100，’a’，3.1415等。 Typed Constants：通过常量声明，将字面量和一个标识符绑定，同时指定特定的类型。 在Go中，对每种类型的字面量有一个预设的类型，将字面量与特定类型的标识符相绑定时，需要考虑兼容性。此外在常量表达式的计算中也需要考虑字面量之间是否可以相互兼容。 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:5","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.6 字面量 字面量，比如1，2.3，true，“Hello\"，字面量也常称为未命名常量 integer constants 100, 67413 floating-point constants 4.56, 128.372 boolean constants true, false rune constants 'C', 'ä' complex constants 2.7i, 3 + 5i string constants \"Hello\", \"Rajeev\" ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:6","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.7 常量声明格式 如果标识符后不加类型，会根据右边的值自动推导类型 const pi = 3.1415926 const e = 2.7182 const str string = \"abc\" // 或 const ( pi float64 = 3.1415926 e float64 = 2.7182 str string = \"abc\" ) // 支持并行赋值 const a, b, c = 1, 2, 3 批量声明：const同时声明多个常量时，如果省略了值，则表示与上一行相同 const ( n1 = 100 n2 n3 ) 注意事项： 不可以用自定义的函数给常量赋值，但内置函数可以，例如len() const testConst = \"test\" const c1 = len(testConst) const c1 = len([]int{2, 3, 4}) // len(([]int literal)) (value of type int) is not constant const c2 = getNumber() // getNumber() (value of type int) is not constant func getNumber() int { return 1 } ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:7","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.8 iota常量生成器 iota是go语言的常量计数器，只能在常量的表达式中使用。 iota在const关键字出现时将被重置为0。 const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。 常见iota示例: 枚举 type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 使用_跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) 在iota中插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 使用iota定义数量级 const ( _ = 1 \u003c\u003c (10 * iota) KiB // 1024 2^10 MiB // 1048576 2^20 GiB // 1073741824 2^30 TiB // 1099511627776 2^40 PiB // 1125899906842624 2^50 EiB // 1152921504606846976 2^60 ZiB // 1180591620717411303424 2^70 YiB // 1208925819614629174706176 2^80 ) // 注意KB和KiB的区别 const ( KB = 1000 MB = 1000 * KB GB = 1000 * MB PB = 1000 * GB ) 多个iota定义在一行 const ( a, b = iota + 1, iota + 2 //1,2 iota = 1 c, d //2,3 iota = 2 e, f //3,4 iota = 3 ) 取消iota // 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式 const ( a = iota // a = 0 b // b = 1 c // c = 2 d = 5 // d = 5 e // e = 5 ) ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:8","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1.9 其他 以下代码中，常量的定义并没有一个明确的基础类型，此时，编译器会为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算 反斜杠\\可以在常量表达式中作为多行的连接符使用 数字型的常量无需担心类型转换问题，它们都是非常理想的数字 当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表示而导致溢出，会在编译期间引发错误 const PI = 3.1415926 const Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009 // 报错，可能是已经移除了这种语法 // const Ln2 = 0.693147180559945309417232121458\\ // 176568075500134360255254120680009 const Log2E = 1/Ln2 // this is a precise reciprocal const Billion = 1e9 // float constant const hardEight = (1 \u003c\u003c 100) \u003e\u003e 97 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:1:9","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2 变量 不同于PHP和Python, Golang是静态类型语言 变量必须先声明后使用 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:0","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.1 变量作用域 一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。 如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包（被导出后可以在外部包）使用。 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。 可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏。 关于作用域的更多信息请参考如下文章ch14 包与变量作用域 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:1","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.2 声明格式 需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。 首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：int* a, b;。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。 标准声明格式 var name string 批量声明格式 var( name string //\"\" age int //0 isOk bool //false ) // 这种因式分解关键字的写法一般用于声明全局变量 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:2","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.3 初始化 可在声明变量的时候为其指定初始值。变量初始化的标准格式如下： var 变量名 类型 = 表达式 举个例子： var name string = \"Q1mi\" var age int = 18 一次初始化多个变量 var name,age = \"QImi\",20 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:3","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.4 类型推导 有时会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化 // 变量类型在编译时实现自动推断 var name = \"Qimi\" var age = 18 // 变量类型在运行时实现自动推断 var ( HOME = os.Getenv(\"HOME\") USER = os.Getenv(\"USER\") GOROOT = os.Getenv(\"GOROOT\") ) ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:4","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.5 短变量声明 这是使用变量的首选形式，但只能被用在函数体内，不可以用于全局变量的声明与赋值。 使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。 在函数内部，可以使用更简略的 := 方式声明并初始化变量 package main import \"fmt\" var m=100 func main(){ m := 10 //局部变量 n := 20 fmt.Println(m,n) } 注意：局部变量声明之后必须使用，单纯的赋值也是不够的，全局变量允许声明但不使用 ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:5","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.6 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如： func foo() (int, string) { return 10, \"Q1mi\" } func main() { x, _ := foo() _, y := foo() fmt.Println(\"x=\", x) fmt.Println(\"y=\", y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。) ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:6","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"2.7 init函数中的变量初始化 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。 这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 一个可能的用途是在开始执行程序之前对数据进行检验或修复，保证程序状态的正确性。 package trans import \"math\" var Pi float64 func init() { Pi = 4 * math.Atan(1) // init() function computes Pi } package main import ( \"fmt\" _ \"chao/trans\" ) var twoPi = 2 * trans.Pi func main() { fmt.Printf(\"2*Pi = %g\\n\", twoPi) // 2*Pi = 6.283185307179586 } init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面例子中的 backend()： func init() { // setup preparations go backend() } ","date":"2021-12-12","objectID":"/2021/12/go-ch6/:2:7","tags":null,"title":"Ch6 常量与变量","uri":"/2021/12/go-ch6/"},{"categories":["golang"],"content":"1 算术运算符 算数运算符包括+,-,*,/,% 注意 ++自增和-自减在Go语言中是单独的语句，并不是运算符 取模运算符%仅用于整数间的运算 整数除以0可能导致程序崩溃，会引发panic；浮点数除以0.0会返回一个无穷尽的结果，使用+Inf表示 /对于整数运算而言，结果依旧为整数，会向着0方向截断余数 Go在进行字符串拼接时允许使用对运算符+的重载，但Go本身不允许开发者进行自定义的运算符重载 在运算时溢出不会产生错误，Go会简单地将超出位数抛弃，如果需要范围无限大的整数或者有理数，可以使用标准库中的big包，该包提供了类似big.Int和big.Rat这样的类型。 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:1:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"2 关系运算符 关系运算符包括==,!=,\u003e,\u003e=,\u003c,\u003c= 布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用==和!=进行比较 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:2:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"3 逻辑运算符 逻辑运算符包括\u0026\u0026、||、! 在格式化输出时，使用%t来表示要输出的值为布尔型 在Go语言中，\u0026\u0026和||是具有快捷性质的运算符（短路性质），当运算符左边表达式的值已经能够决定整个表达式的值时，运算符右边的表达式不会被执行。利用这个特性，如果有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧。 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:3:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"4 位运算符 位运算符对整数在内存中的二进制位进行操作 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:4:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"4.1 一元运算符 ^ 按位取反 \u003c\u003c bitP的位向左移动n位，算术上左移n位等价于乘以2的n次方 \u003e\u003e bitP的位向右移动n位，算术上右移n位等价于除以2的n次方 对于无符号数，左移和右移都是用0填充空缺的bit位 对于有符号数，右移运算会用符号位的值填充左边空缺的bit位 因此，最好用无符号运算，这样可以将整数完全当作一个bit位模式处理 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:4:1","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"4.2 二元运算符 \u0026 参与运算的两数各对应的二进位相与 | 参与运算的两数各对应的二进位相或 ^ 参与运算的两数各对应的二进位相异或，相异为1 \u0026^ 位清除运算，将指定位置上的值设置位0 位清空操作：a \u0026^ b，在a中，将一些位置的值设置为0，而这些位置由b确定。b用二进制表示，二进制为1的位置就是a中要清空的位置。 package main import \"fmt\" func main() { a := 12 b := 4 c := a \u0026^ b fmt.Printf(\"a: %08b\\n\", a) fmt.Printf(\"b：%08b\\n\", b) fmt.Printf(\"c: %#v 二进制：%08b\\n\",c,c) /*输出： a: 00001100 b：00000100 c: 8 二进制：00001000 */ } ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:4:2","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"5 赋值运算符 赋值运算符包括=，+=，-=，*=，/=，%=，\u003c\u003c=，\u003e\u003e=，\u0026=，|=，^= ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:5:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"6 运算符与优先级 优先级 运算符 7 ^ ! (一元运算符) 6 * / % \u003c\u003c \u003e\u003e \u0026 \u0026^ 5 + - | ^ 4 == != \u003c \u003c= \u003e= \u003e 3 \u003c- 2 \u0026\u0026 1 || 在同一个优先级中，使用左优先结合规则， 但是使用括号可以明确优先顺序，也可以用于提升优先级，比如mask \u0026 (1 \u003c\u003c 28) 关于 \u003c- 运算符的更多信息参考ch22 通道 ","date":"2021-12-11","objectID":"/2021/12/go-ch5/:6:0","tags":null,"title":"Ch5 运算符","uri":"/2021/12/go-ch5/"},{"categories":["golang"],"content":"关于Go语言中的类型 引用 Go语言中的类型可以是 基本类型，如：整型、浮点型、布尔、字符串等 复合类型，如：数组、结构体等 引用类型，如：指针、切片、字典、函数、通道等 接口类型，如：接口等 以上内容摘自 https://topgoer.cn/docs/gopl-zh/gopl-zh-1d2a096ino06l 引用 类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。 以上内容摘自 https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.2.md 引用 其他相关的分类：https://gfw.go101.org/article/type-system-overview.html 关于类型的说法很多，个人认为需要记住的是如下内容 值类型，如：int、float、bool、string、array、struct 引用类型，如：ptr、slice、map、channel、func、interface 值类型与引用类型的区别： 值类型变量直接存储值，内存通常在栈中分配 引用类型变量存储一个地址（默认值为nil），内存通常在堆上分配 具体地，请参考Go 内存管理机制 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:0:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1 数字 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:1:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1.1 整型 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 注意事项： 在使用int和uint类型时，不能假定它是32位或者64位的整型，而是考虑int和uint可能在不同平台上的差异。 uintptr没有指定具体的bit大小，但是足够容纳指针，一般只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，map或切片的元素数量等都可以用int表示。 但是在涉及到二进制传输，读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和uint。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:1:1","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1.2 浮点数 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准：float32浮点数的最大范围约为3.4e38，常量定义为math.MaxFloat32; float64浮点数的最大范围约为1.8e308，常量定义为math.MaxFloat64 float32精确到小数点后7位，float64精确到小数点后15位。使用==或!=来比较浮点数时应当非常小心，在正式使用前测试对于精确度要求比较高的运算。 math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试 +Inf和-Inf 分别表示正无穷大和负无穷大 NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1). var z float64 fmt.Println(z, -z, 1/z, -1/z, z/z) // \"0 -0 +Inf -Inf NaN\" 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。 虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）： nan := math.NaN() fmt.Println(nan == nan, nan \u003c nan, nan \u003e nan) // \"false false false\" 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，像这样： func compute() (value float64, ok bool) { // ... if failed { return 0, false } return result, true } ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:1:2","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1.3 复数 complex64和complex128 复数有实部和虚部，complex64的实部和虚部为float32，complex128的实部和虚部为float64 使用字面量创建复数 var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i // 或者 // c1 := 1 + 2i // c2 := 2 + 3i 使用complex函数创建复数 如果实数部分和虚数部分的类型均为float32，那么类型为complex64的复数c可以通过以下方式来获得 c := complex(re, im) fmt.Println(real(c)) fmt.Println(imag(c)) // 函数`real(c)`和`imag(c)`可以分别获得相应的实数和虚数部分。 +、、 、 / 运算符支持实数与实数、实数与复数、复数与复数的运算，但%不能用于复数 复数支持和其他数字类型一样的运算，当使用等号==或不等号!=对复数进行比较运算时，注意对精确度的把握。 math/cmplx包中包含了一些操作复数的公共方法，接收的类型都是complex128。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:1:3","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1.4 数字字面量语法 Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如： num1 := 0b00101101 // 代表二进制的 101101，相当于十进制的 45 num2 := 0o366 // 代表八进制的 377，相当于十进制的 255 num3 := 0x1p-2 // 代表十六进制的 1 除以 2²，也就是 0.25 num4 := 123_456 // 允许用 _ 来分隔数字，比如说：v := 123_456 等于 123456。 const e = 2.71828 // (approximately) 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分： const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 注意事项 num3 := 1p-2 会报错 ‘p’ exponent requires hexadecimal mantissa，这种方式只能用于十六级进制 八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。 浮点数的字面值，其中小数点前面或后面的数字都可能被省略（例如.707或1.） ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:1:4","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2 字符与字符串 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.1 byte、rune Go 语言的字符有以下两种： uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 Unicode码点。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。 Unicode字符(rune类型)是和int32等价的类型，通常用于表示一个Unicode码点。 byte是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。 引用 关于字符编码unicode utf-8等相关知识，可参考http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:1","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.2 byte、rune的字面量 技巧 关于\\x41、\\101，\\u03B2，\\U00101234的用法会在下文字符串转义部分进行解释 byte 在ASCII码表中，A的值是65，而使用16进制表示则为41，所以下面的写法是等效的 var ch byte = 65 var ch byte = '\\x41' // \\x 后跟长度为2的16进制数 var ch byte = '\\101' // \\ 后跟长度为3的8进制数 rune 在书写Unicode字符时，需要在16进制数之前加上前缀\\u或者\\U 前缀 \\u 总是紧跟着长度为 4 的 16 进制数，前缀 \\U 紧跟着长度为 8 的 16 进制数。 var ch int = '\\u0041' var ch2 int = '\\u03B2' var ch3 int = '\\U00101234' fmt.Printf(\"%d - %d - %d\\n\", ch, ch2, ch3) // integer fmt.Printf(\"%c - %c - %c\\n\", ch, ch2, ch3) // character fmt.Printf(\"%X - %X - %X\\n\", ch, ch2, ch3) // UTF-8 bytes fmt.Printf(\"%U - %U - %U\", ch, ch2, ch3) // UTF-8 code point //65 - 946 - 1053236 //A - β - r //41 - 3B2 - 101234 //U+0041 - U+03B2 - U+101234 %d：十进制表示 %c：相应Unicode码点所表示的字符 %X：十六进制表示，字母位大写形式 %U：Unicode格式：U+1234 格式占位符将在ch7 基本输入输出中进一步进行说明 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 包 utf8 拥有更多与 rune 类型相关的函数。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:2","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.3 字符串 字符串的底层结构 Go语言里的字符串的内部实现使用utf-8编码。 字符串底层的是一个byte数组+字符串长度len。“hi，我是小明\"这一个字符串，将把每个Unicode码点使用UTF-8进行统一编码，从而得到一个字节数组。 Go编译器认为字符串通常是不可修改的，故会将字符串存储在常量区，因此尝试修改字符串内部数据的操作也是被禁止的： str := \"hi, 我是小明\" str[0] = 'H' // compile error: cannot assign to s[0] 不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。 同样，一个字符串s和对应的子字符串切片的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。 在这两种情况下都没有必要分配新的内存。 str := \"helloworld\" substr1 := str[0:5] substr2 := str[5:] fmt.Println(str, substr1, substr2) str = \"hiworld\" fmt.Println(str, substr1, substr2) // helloworld hello world // hiworld hello world 字符串的遍历 // 遍历字符串 func traversalString() { s := \"hello沙河\" for i := 0; i \u003c len(s); i++ { //byte fmt.Printf(\"%v(%c) \", s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(\"%v(%c) \", r, r) } fmt.Println() } 输出： 104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 正如上述所说，字符串底层是一个byte数组，len(str)得到的结果是byte数组的长度，而UTF8编码下一个中文汉字（通常）由3个字节组成，所以不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。此时，可以采用for range方式来遍历字符串，for range方式是遍历字符串中的rune，即Unicode码点 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:3","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.4 字符串转义符 \\r 回车符（返回至行首) \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 除了上述的字符外，还有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构（例如在中文和日文中就有很多相似但不同的字），有一些甚至是不可见的字符。为了解决这个问题，Go语言字符串字面量中的Unicode转义字符允许可以通过Unicode码点输入特殊的字符。 有两种方法： 方法1：使用UTF-8后的编码值（\\x）。将Unicode码点值使用UTF-8编码后得到hhhhhh，使用\\xhh\\xhh\\xhh序列表示编码hhhhhh，以此来插入该Unicode码点。 方法2：使用Unicode码点值（\\u或\\U）。\\uhhhh（16bit的码点值）或\\Uhhhhhhhh（32bit的码点值）。 例如：下面的字母串面值都表示相同的值： \"世界\" // 世界的Unicode U+4E16 U+754C \"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\" // 将 U+4E16 U+754C转化成UTF-8编码之后的值了 \"\\u4e16\\u754c\" \"\\U00004e16\\U0000754c\" 无论是方法一还是方法二，其实向底层的[]byte数组中填入的都是同样的数据，即方法一中的数值，0xe4,0xb8,0x96,0xe7,0x95,0x8c。 当需要读取数据时，会对比特流进行解码，从而获取数据。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:4","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.5 rune与转义符 Unicode转义也可以使用在表示rune字符中。下面三个字符是等价的： '世' '\\u4e16' '\\U00004e16' 此外，对于码点值小于等于0x7F的码点，可以使用例如\\x41（对应字符A）的形式表示对应的码点，但是对于更大的码点，例如'世'则必须使用\\u或\\U转义形式，而不是ch = '\\xe4\\xb8\\x96'。 原因： 能使用\\x41表示字符’A’是因为0x41不仅是字符’A’的Unicode码点，也是其经过UTF-8后的编码值。 '\\xe4\\xb8\\x96' 会经历三次转义，每个\\x分别代表了一个rune字符，且均为不合法字符。 import \"fmt\" int main() { s := \"\\u0041\\u00FF\\x41\\xC3\\xBF\\xFF\" fmt.Println(s) } // AÿAÿ� 关于�的说明如下： 每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符\\uFFFD，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号”?”。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:5","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"2.6 原生字符串 一个原生的字符串面值形式是使用反引号代替双引号。 在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。 在原生字符串面值内部是无法直接写字符的，可以用八进制或十六进制转义或用+**\"\"**连接字符串常量完成 唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。 原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。 const GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ...` ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:2:6","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"3 布尔 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true和flase两个值 注意： 布尔类型变量的默认值false Go语言中不允许将整型强制转换为布尔型 布尔型无法参与数值运算，也无法与其他类型进行转换 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:3:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"4 类型转换 Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。 强制类型转换的基本语法为：T(表达式)，其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等. 比如，计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。 func sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } 对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。 但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度： f := 3.141 // a float64 i := int(f) fmt.Println(f, i) // \"3.141 3\" f = 1.99 fmt.Println(int(f)) // \"1\" 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。 应该避免对可能会超出目标类型表示范围的数值做类型转换，因为截断的行为可能依赖于具体的实现： f := 1e100 // a float64 i := int(f) // 结果依赖于具体实现 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:4:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"5 值传递 基本类型是Go语言自带的类型，比如数值类型，浮点型，字符类型和布尔类型，它们本质上是原始类型，也就是不可改变，所以对它们进行操作，一般都会返回一个新创建的值。所以把这些值传递给函数时，其实传递的是一个值的副本。 func main(){ name:=\"张三\" fmt.Println(modift(name)) fmt.Println(name) } func modify(s string) string{ s=s+s return s } 基本类型因为是拷贝的值，并且在对它进行操作的时候，生成的也是新创建的值，所以这些类型在多线程里是安全的，不用担心一个线程的修改影响了另外一个线程的数据。 ","date":"2021-12-10","objectID":"/2021/12/go-ch4/:5:0","tags":null,"title":"Ch4 基本数据类型","uri":"/2021/12/go-ch4/"},{"categories":["golang"],"content":"1 标识符及命名规范 在编程语言中标识符是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。 命名规范： 推荐使用驼峰式命名 大小写敏感，heapSort和Heapsort不同 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。 ","date":"2021-12-08","objectID":"/2021/12/go-ch3/:1:0","tags":null,"title":"Ch3 标识符与关键字","uri":"/2021/12/go-ch3/"},{"categories":["golang"],"content":"2 关键字与保留字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。 Go语言中有25个关键字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 关键字少，是为了简化在编译过程第一步中的代码解析。 此外，Go语言中还有30多个保留字，比如,int和true等，主要对应内建的常量、类型和函数这些内部预定义的名字并不是关键字，可以在定义中重新使用，但应尽量避免重定义，一面影起语义混乱。 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 引用 https://www.liwenzhou.com/posts/Go/01_var_and_const/ https://topgoer.cn/docs/gopl-zh/gopl-zh-1d2a07a5bc4o0 对于保留字的说法，在别处看到了不同的描述，摘录于此。 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数。 引用 https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.1.md ","date":"2021-12-08","objectID":"/2021/12/go-ch3/:2:0","tags":null,"title":"Ch3 标识符与关键字","uri":"/2021/12/go-ch3/"},{"categories":["golang"],"content":"在上一章中，运行了如下程序， package main import \"fmt\" func main(){ fmt.Println(\"hello world!\") } 下面将结合此程序，进行一些简单的说明。 ","date":"2021-12-06","objectID":"/2021/12/go-ch2/:0:0","tags":null,"title":"Ch2 Hello World","uri":"/2021/12/go-ch2/"},{"categories":["golang"],"content":"1 Go语言中的包 Go语言的代码通过包（package）组织，一个包由位于单个目录下的一个或多个.go源代码文件组成。包中的每个源文件都以一条package声明语句开始，在这个例子里就是package main，表示该文件属于哪个包。 Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数，Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。 main包比较特殊，它定义了一个独立可执行的程序，在main包中的main 函数是整个程序执行时的入口。 必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。 必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包。 有个相关的工具，goimports，可以根据代码需要，自动地添加或删除import声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装： $ go get golang.org/x/tools/cmd/goimports ","date":"2021-12-06","objectID":"/2021/12/go-ch2/:1:0","tags":null,"title":"Ch2 Hello World","uri":"/2021/12/go-ch2/"},{"categories":["golang"],"content":"Go语言风格 Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。 实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析。 示例 比如行末是下列内容时，将自动把换行符转换为分号： 标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个。 当换行符错误添加时，可能会导致编译不通过，例如 函数的左括号{必须和func函数声明在同一行上，且位于末尾，不能独占一行。 在表达式x + y中，可在+后换行，不能在+前换行 示例 以+结尾不会被插入分号分隔符，但以x结尾则会插入分号分隔符，从而导致编译错误。 Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（该格式化工具没有任何可以调整代码格式的参数），并且go工具中的fmt子命令会对指定包（默认为当前目录）中所有.go源文件应用gofmt命令。这样可以的好处是少了争议，且便于做多种自动源码转换。很多文本编辑器都可以配置为保存文件时自动执行gofmt，这样源代码总会被恰当地格式化。 ","date":"2021-12-06","objectID":"/2021/12/go-ch2/:2:0","tags":null,"title":"Ch2 Hello World","uri":"/2021/12/go-ch2/"},{"categories":["golang"],"content":"Go程序的基本结构 下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。 包名，例如package main 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在init 函数的话，则对该函数进行定义。这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数，在之后会再次提到。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 package main import ( \"fmt\" ) const c = \"C\" var v int = 5 type T struct{} func init() { // initialization of package } func main() { var a int Func1() // ... fmt.Println(a) } func (t T) Method1() { //... } func Func1() { // exported function Func1 //... } Go 程序的执行（程序启动）顺序如下： 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 ","date":"2021-12-06","objectID":"/2021/12/go-ch2/:3:0","tags":null,"title":"Ch2 Hello World","uri":"/2021/12/go-ch2/"},{"categories":["golang"],"content":"1 下载 下载地址：https://golang.google.cn/dl/ 根据环境，下载所需版本 ","date":"2021-12-05","objectID":"/2021/12/go-ch1/:1:0","tags":null,"title":"ch1 安装与环境配置","uri":"/2021/12/go-ch1/"},{"categories":["golang"],"content":"2 配置环境变量 GOROOT GOROOT表示Go语言的安装目录，将GOROOT的值设置为对应的安装目录。 此外，GOROOT/bin则包含GO提供的工具链，应将GOROOT/bin配置到环境变量PATH中，从而能够在全局中使用GO工具链。 GOPATH Go1.8版本之前，GOPATH环境变量默认是空的，从Go1.8版本之后，Go开发包会在安装完成之后为GOPATH设置一个默认目录，如果是windows系统，打开环境变量可看到默认目录，如有需要可进行修改。 在Go较老的版本中，除了Go的SDK外，所有代码都推荐放置在GOPATH目录下。此时GOROOT和GOPATH分别指向系统安装路径和工作路径，这样的好处是自己编写的代码与系统文件分离。 在Go1.11版本中推出了Go Modules，使用Go Module模式以后可以不用将代码放置在$GOPATH/src下了。 在较新的版本中，会自动启用Go Module模式，可通过输入go env -w GO111MODULE=off关闭，或者输入go env -w GO111MODULE=on 开启 配置完环境变量后，打开终端输入go version，若看到输出go的版本信息则证明配置成功。 ","date":"2021-12-05","objectID":"/2021/12/go-ch1/:2:0","tags":null,"title":"ch1 安装与环境配置","uri":"/2021/12/go-ch1/"},{"categories":["golang"],"content":"3 Go PATH 与 Go Module 信息 由于Go PATH的局限性，该模式几乎已不再使用 在进行Go语言开发的时候，代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后之后， 会将下载的第三方包源代码文件放在$GOPATH/src目录下 产生的二进制可执行文件放在 $GOPATH/bin目录下 生成的中间缓存文件会被保存在 $GOPATH/pkg 下。 如果使用版本管理工具（Version Control System，VCS。常用如Git）来管理项目代码，只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需进行版本控制。 但在Go1.11引入Go Modules之后，代码不必强制放置在$GOPATH/src下了，可以是任意一个文件夹。 关于Go的相关命令的更多信息请参考Go依赖管理 ","date":"2021-12-05","objectID":"/2021/12/go-ch1/:3:0","tags":null,"title":"ch1 安装与环境配置","uri":"/2021/12/go-ch1/"},{"categories":["golang"],"content":"4 Hello World程序 E: mkdir workspace_go cd workspace_go mkdir helloworld cd helloworld // helloword是这个模块的名字，可任意指定 go mod init helloworld go mod tidy 新建main.go文件，并输入以下内容 package main import \"fmt\" func main() { fmt.Println(\"hello world\") } 回到终端，输入以下命令执行 go build main.go main.exe // 或者 go run main.go 关于Go的相关命令的更多信息请参考Go指令 ","date":"2021-12-05","objectID":"/2021/12/go-ch1/:4:0","tags":null,"title":"ch1 安装与环境配置","uri":"/2021/12/go-ch1/"},{"categories":["golang"],"content":"5 VS Code安装与使用 下载VS Code，应用商店搜索chinese，安装汉化包插件，应用商店搜索go，安装插件。 打开目标文件夹，新建main.go文件，执行go mod init modlueName和go mod tidy ，modlueName是指这个模块的名字，可任意输入。在main.go中输入以下代码 package main import \"fmt\" func main() { fmt.Println(\"hello world!\") } 右键main.go 在终端中打开，终端选择cmd，输入go build或go run指令。 问题 若在vscode打开的终端内，提示没有找到该命令。 右键-\u003e属性-\u003e兼容性-\u003e管理员身份运行，原因 原因：配置了系统变量，而不是用户变量，所以需要管理员权限。 插件的安装：在使用vscode的过程中会不断提示下载插件，一般都很难下载成功。此时需要设置代理，打开终端输入go env -w GOPROXY=https://goproxy.cn,direct ，然后再去下载。 ​ ","date":"2021-12-05","objectID":"/2021/12/go-ch1/:5:0","tags":null,"title":"ch1 安装与环境配置","uri":"/2021/12/go-ch1/"},{"categories":null,"content":" 徐家庄电器装修学校 在读研究生 期望毕业能找到一份工作，好好做一个Gopher 邮箱：zchaoyu1126@gmail.com 状态：焦虑焦虑焦虑 ","date":"2021-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"Go语言学习资料：【传送门】 ","date":"0001-01-01","objectID":"/documentation/golang/:0:0","tags":null,"title":"Golang","uri":"/documentation/golang/"}]