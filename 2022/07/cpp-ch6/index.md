# 第六章 多态性与虚函数


### 6.1 类型兼容原则

类型兼容规则是指在需要基类对象的任何地方，都可以使用**公有派生类的对象**来替代。

主要有以下三种情况：（具体代码参考6.4节）

- 派生类的对象可以赋值给基类的对象。
- 派生类的对象可以初始化基类的引用。
- 派生类的对象的地址可以赋值给基类的指针变量。

**只能用派生类对象对其基类对象赋值，而不能用基类对象对其派生类对象赋值。同一基类的不同派生类对象之间也不能赋值。**

### 6.2 多态和联编

多态（Polymorphism）是指具有相似功能的不同函数使用同一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数的特性。

C++支持的多态可以分为四种类型：

1. 重载多态：函数重载和运算符重载
2. 强制多态：强制类型转换
3. 包含多态：虚函数
4. 参数多态：函数模板和类模板

从实现的角度来划分：编译时多态和运行时多态

C++采用联编技术来支持多态。联编是指把一个标识符名和一个存储地址联系在一起的过程。在多态的实现过程中，确定调用哪个同名函数的过程就是联编，又称绑定。

### 6.3 联编的分类

静态联编：**在编译阶段完成**，通常在**重载时**使用。静态联编支持**编译时多态**，也称静态多态。速度快，不灵活。

动态联编：**在运行阶段完成**，通过**继承和虚函数**实现。动态联编支持**运行时多态**，也称动态多态。够灵活，不够快。

**运行时多态要满足3个条件**：

1. 类之间应满足类型兼容规则。
2. 同名声明虚函数
3. 成员函数来调用或者是通过指针、引用来访问虚函数

### 6.4 虚函数

声明虚函数的格式为：

```cpp
virtual <函数值类型> <函数名>(<参数表>);
```

在派生类中重新定义虚函数时，其函数原型包括返回类型、函数名、参数个数、类型和顺序，都必须与基类中的原型相同。

一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。

当虚函数声明与实现分开时，virtual关键字只用在虚函数的声明中，不能用在虚函数的实现中。

{{< admonition info "虚函数与联编">}}

只有通过**对象指针或对象引用**来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式。

{{< /admonition>}}

```cpp
#include <iostream>
using namespace std;

class Student {
public:
    virtual void print() {
        cout<<"A student"<<endl;
    }
};

class GStudent:public Student {
public:
    //关键字virtual可以省略
    virtual void print() { 
        cout<<"A graduate student"<<endl; 
    }
};

int main() {
    Student s1, *ps, s3;
    GStudent s2;
    s1.print();
    s2.print();
    s2.Student::print();
    cout << "*******" << endl;
    ps = &s1;       
    ps->print();
    ps = &s2;           // 派生类的对象的地址可以赋值给基类的指针变量
    ps->print();        // 对象指针调用虚函数，采用动态联编方式
    cout << "*******" << endl;
    s3 = s2;            // 派生类的对象可以赋值给基类的对象
    s3.print();         // 对象来调用虚函数，采用静态联编方式
    Student &s4 = s2;   // 通过对象引用来调用虚函数，实现动态联编
    s4.print();
    return 0;
}
```

**注意事项**：

1. 静态成员函数不能是虚函数，不属于某个对象，没有多态性
2. **构造函数不能是虚函数**，因为虚函数作为运行时多态性的基础，主要是针对对象的，在构造函数之前对象还没有被创建。
3. **内联成员函数不能是虚函数**。因为内联函数的执行代码是明确的，在编译时已被替换，没有多态性的特征。如果将那些在类声明时就定义内容的成员函数声明为虚函数，此时函数不是内联函数，而以多态性出现。
4. **析构函数可以是虚函数。**

### 6.5 虚析构函数

虚析构函数定义后，先调用派生类的析构函数，再调用基类的派生函数，这样对象才被安全析构。

### 6.6 构造函数和成员函数中调用虚函数

构造函数调用虚函数**是静态联编的，**成员函数调用虚函数是**动态联编的**

### 6.7 纯虚函数

**纯虚函数用virtual声明，没有任何实现、必须由派生类覆盖该函数提供实现。**

纯虚函数不需要定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。

纯虚函数的声明格式为：

```cpp
virtual <函数值类型> <函数名>(<参数表>)=0;
```

### 6.8 抽象类

含有一个或多个纯虚函数的类称为抽象类，**抽象类不能被实例化。**没有实现纯虚函数的派生类也是抽象类。
